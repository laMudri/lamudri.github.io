<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-GB" xml:lang="en-GB">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="James Wood" />
  <meta name="dcterms.date" content="2019-08-22" />
  <title>Vectors and Matrices in Agda</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <p><link href="./Agda.css" rel="stylesheet" type="text/css" media="all"></p>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Vectors and Matrices in Agda</h1>
<p class="author">James Wood</p>
<p class="date">2019-08-22</p>
</header>
<p>A recent project of mine has been to formalise and reformalise some basic linear algebra in Agda. This was motivated directly by <a href="../../pub/types2019-linear-substitution.pdf">our recent result</a> that many syntactic properties of usage-tracking type systems benefit from being stated in terms of vectors and matrices. This form of usage tracking appears to be exactly powerful enough to capture intuitionistic linear <em>logic</em>, so involvement of linear <em>algebra</em> is in some sense unsurprising. The similarities go further than the names.</p>
<p>The aim for this post is to describe and justify the method I have settled on. The challenge is to take an arbitrary semiring (rig) <code>R</code> of coefficients and define vectors, matrices, matrix addition, and matrix multiplication, and then prove all of the expected properties of these operations. We will not consider performance, mainly because I neither know nor care at the moment.</p>
<p>For the impatient, my recommendations are the following four points.</p>
<ul>
<li>Define vectors and matrices as functions from positions to coefficients.</li>
<li>Positions are (single/pairs of) <code>Fin</code>s, with definitional equality as good as equivalence.</li>
<li>Define the identity matrix via an equality test on the indices of each position, rather than trying an inductive construction.</li>
<li>Do not define this equality test via the decidability of equality of <code>Fin n</code>.</li>
</ul>
<p>Obligatory literate blog post notes: this post comes from a literate Agda file, of which many parts have been surpressed. Defined names are clickable. The full source code is available at <a href="../VecMat.lagda.md">VecMat.lagda.md</a>, and depends just on the Standard Library. I have tried to make the Agda code readable at a high level, particularly by using equational reasoning syntax.</p>
<!--
<pre class="Agda"><a id="1955" class="Keyword">module</a> <a id="1962" href="VecMat.html" class="Module">VecMat</a> <a id="1969" class="Keyword">where</a>

<a id="1976" class="Keyword">open</a> <a id="1981" class="Keyword">import</a> <a id="1988" href="Algebra.html" class="Module">Algebra</a>
<a id="1996" class="Keyword">open</a> <a id="2001" class="Keyword">import</a> <a id="2008" href="Data.Nat.html" class="Module">Data.Nat</a> <a id="2017" class="Symbol">as</a> <a id="2020" class="Module">N</a> <a id="2022" class="Keyword">using</a> <a id="2028" class="Symbol">(</a><a id="2029" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a><a id="2030" class="Symbol">;</a> <a id="2032" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a><a id="2036" class="Symbol">;</a> <a id="2038" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a><a id="2041" class="Symbol">)</a>
<a id="2043" class="Keyword">open</a> <a id="2048" class="Keyword">import</a> <a id="2055" href="Data.Fin.html" class="Module">Data.Fin</a> <a id="2064" class="Keyword">using</a> <a id="2070" class="Symbol">(</a><a id="2071" href="Data.Fin.Base.html#1000" class="Datatype">Fin</a><a id="2074" class="Symbol">;</a> <a id="2076" href="Data.Fin.Base.html#1022" class="InductiveConstructor">zero</a><a id="2080" class="Symbol">;</a> <a id="2082" href="Data.Fin.Base.html#1053" class="InductiveConstructor">suc</a><a id="2085" class="Symbol">;</a> <a id="2087" href="Data.Fin.Properties.html#1730" class="Function Operator">_≟_</a><a id="2090" class="Symbol">)</a>
<a id="2092" class="Keyword">open</a> <a id="2097" class="Keyword">import</a> <a id="2104" href="Data.Fin.Properties.html" class="Module">Data.Fin.Properties</a> <a id="2124" class="Symbol">as</a> <a id="2127" class="Module">FP</a> <a id="2130" class="Keyword">using</a> <a id="2136" class="Symbol">(</a><a id="2137" href="Data.Fin.Properties.html#1626" class="Function">suc-injective</a><a id="2150" class="Symbol">)</a>
<a id="2152" class="Keyword">open</a> <a id="2157" class="Keyword">import</a> <a id="2164" href="Data.Bool.html" class="Module">Data.Bool</a> <a id="2174" class="Keyword">using</a> <a id="2180" class="Symbol">(</a><a id="2181" href="Agda.Builtin.Bool.html#135" class="Datatype">Bool</a><a id="2185" class="Symbol">;</a> <a id="2187" href="Agda.Builtin.Bool.html#154" class="InductiveConstructor">false</a><a id="2192" class="Symbol">;</a> <a id="2194" href="Agda.Builtin.Bool.html#160" class="InductiveConstructor">true</a><a id="2198" class="Symbol">;</a> <a id="2200" href="Data.Bool.Base.html#1312" class="Function Operator">if_then_else_</a><a id="2213" class="Symbol">;</a> <a id="2215" href="Data.Bool.Base.html#1480" class="Function">T</a><a id="2216" class="Symbol">;</a> <a id="2218" href="Data.Bool.Base.html#961" class="Function">not</a><a id="2221" class="Symbol">)</a>
<a id="2223" class="Keyword">open</a> <a id="2228" class="Keyword">import</a> <a id="2235" href="Data.Product.html" class="Module">Data.Product</a> <a id="2248" class="Symbol">as</a> <a id="2251" class="Module">Σ</a> <a id="2253" class="Keyword">using</a> <a id="2259" class="Symbol">(</a><a id="2260" href="Agda.Builtin.Sigma.html#139" class="Record">Σ</a><a id="2261" class="Symbol">;</a> <a id="2263" href="Data.Product.html#1364" class="Function">∃</a><a id="2264" class="Symbol">;</a> <a id="2266" href="Data.Product.html#1162" class="Function Operator">_×_</a><a id="2269" class="Symbol">;</a> <a id="2271" href="Agda.Builtin.Sigma.html#225" class="Field">proj₁</a><a id="2276" class="Symbol">;</a> <a id="2278" href="Agda.Builtin.Sigma.html#237" class="Field">proj₂</a><a id="2283" class="Symbol">;</a> <a id="2285" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">_,_</a><a id="2288" class="Symbol">)</a>
<a id="2290" class="Keyword">open</a> <a id="2295" class="Keyword">import</a> <a id="2302" href="Function.html" class="Module">Function</a> <a id="2311" class="Keyword">using</a> <a id="2317" class="Symbol">(</a><a id="2318" href="Function.html#708" class="Function">id</a><a id="2320" class="Symbol">;</a> <a id="2322" href="Function.html#1099" class="Function Operator">_∘_</a><a id="2325" class="Symbol">)</a>
<a id="2327" class="Keyword">open</a> <a id="2332" class="Keyword">import</a> <a id="2339" href="Level.html" class="Module">Level</a> <a id="2345" class="Keyword">using</a> <a id="2351" class="Symbol">(</a><a id="2352" href="Agda.Primitive.html#408" class="Postulate">Level</a><a id="2357" class="Symbol">)</a>
<a id="2359" class="Keyword">open</a> <a id="2364" class="Keyword">import</a> <a id="2371" href="Relation.Binary.html" class="Module">Relation.Binary</a>
<a id="2387" class="Keyword">open</a> <a id="2392" class="Keyword">import</a> <a id="2399" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="2437" class="Symbol">as</a> <a id="2440" class="Module">≡</a> <a id="2442" class="Keyword">using</a> <a id="2448" class="Symbol">(</a><a id="2449" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">_≡_</a><a id="2452" class="Symbol">;</a> <a id="2454" href="Relation.Binary.PropositionalEquality.Core.html#799" class="Function Operator">_≢_</a><a id="2457" class="Symbol">)</a>
<a id="2459" class="Keyword">import</a> <a id="2466" href="Relation.Binary.Reasoning.Setoid.html" class="Module">Relation.Binary.Reasoning.Setoid</a> <a id="2499" class="Symbol">as</a> <a id="2502" class="Module">SetoidReasoning</a>
<a id="2518" class="Keyword">open</a> <a id="2523" class="Keyword">import</a> <a id="2530" href="Relation.Unary.html" class="Module">Relation.Unary</a> <a id="2545" class="Keyword">using</a> <a id="2551" class="Symbol">(</a><a id="2552" href="Relation.Unary.html#1039" class="Function">Pred</a><a id="2556" class="Symbol">)</a>
<a id="2558" class="Keyword">open</a> <a id="2563" class="Keyword">import</a> <a id="2570" href="Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="2587" class="Keyword">using</a> <a id="2593" class="Symbol">(</a><a id="2594" href="Relation.Nullary.html#535" class="Function Operator">¬_</a><a id="2596" class="Symbol">;</a> <a id="2598" href="Relation.Nullary.html#605" class="Datatype">Dec</a><a id="2601" class="Symbol">;</a> <a id="2603" href="Relation.Nullary.html#641" class="InductiveConstructor">yes</a><a id="2606" class="Symbol">;</a> <a id="2608" href="Relation.Nullary.html#668" class="InductiveConstructor">no</a><a id="2610" class="Symbol">)</a>

<a id="2613" class="Keyword">variable</a>
  <a id="2624" href="VecMat.html#2624" class="Generalizable">a</a> <a id="2626" href="VecMat.html#2626" class="Generalizable">a′</a> <a id="2629" href="VecMat.html#2629" class="Generalizable">b</a> <a id="2631" href="VecMat.html#2631" class="Generalizable">b′</a> <a id="2634" href="VecMat.html#2634" class="Generalizable">c</a> <a id="2636" href="VecMat.html#2636" class="Generalizable">c′</a> <a id="2639" href="VecMat.html#2639" class="Generalizable">ℓ</a> <a id="2641" class="Symbol">:</a> <a id="2643" href="Agda.Primitive.html#408" class="Postulate">Level</a>
  <a id="2651" href="VecMat.html#2651" class="Generalizable">A</a> <a id="2653" class="Symbol">:</a> <a id="2655" class="PrimitiveType">Set</a> <a id="2659" href="VecMat.html#2624" class="Generalizable">a</a>
  <a id="2663" href="VecMat.html#2663" class="Generalizable">B</a> <a id="2665" class="Symbol">:</a> <a id="2667" class="PrimitiveType">Set</a> <a id="2671" href="VecMat.html#2629" class="Generalizable">b</a>
  <a id="2675" href="VecMat.html#2675" class="Generalizable">C</a> <a id="2677" class="Symbol">:</a> <a id="2679" class="PrimitiveType">Set</a> <a id="2683" href="VecMat.html#2634" class="Generalizable">c</a>
  <a id="2687" href="VecMat.html#2687" class="Generalizable">A′</a> <a id="2690" class="Symbol">:</a> <a id="2692" class="PrimitiveType">Set</a> <a id="2696" href="VecMat.html#2626" class="Generalizable">a′</a>
  <a id="2701" href="VecMat.html#2701" class="Generalizable">B′</a> <a id="2704" class="Symbol">:</a> <a id="2706" class="PrimitiveType">Set</a> <a id="2710" href="VecMat.html#2631" class="Generalizable">b′</a>
  <a id="2715" href="VecMat.html#2715" class="Generalizable">C′</a> <a id="2718" class="Symbol">:</a> <a id="2720" class="PrimitiveType">Set</a> <a id="2724" href="VecMat.html#2636" class="Generalizable">c′</a>
  <a id="2729" href="VecMat.html#2729" class="Generalizable">m</a> <a id="2731" href="VecMat.html#2731" class="Generalizable">n</a> <a id="2733" href="VecMat.html#2733" class="Generalizable">o</a> <a id="2735" href="VecMat.html#2735" class="Generalizable">p</a> <a id="2737" class="Symbol">:</a> <a id="2739" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a>
</pre>-->
<h2 id="the-naïve-approach">The naïve approach</h2>
<p>If you just want to read the right way of doing things, skip to <a href="#using-what-we-learnt">Using what we learnt</a>.</p>
<!--
<pre class="Agda"><a id="2914" class="Keyword">module</a> <a id="Naïve"></a><a id="2921" href="VecMat.html#2921" class="Module">Naïve</a> <a id="2927" class="Keyword">where</a>
</pre>-->
<p>Everyone’s favourite dependent type family is the <em>vectors</em>, defined as follows.</p>
<pre class="Agda">  <a id="3034" class="Keyword">infixr</a> <a id="3041" class="Number">5</a> <a id="3043" href="VecMat.html#3118" class="InductiveConstructor Operator">_∷_</a>
  <a id="3049" class="Keyword">data</a> <a id="Naïve.Vec"></a><a id="3054" href="VecMat.html#3054" class="Datatype">Vec</a> <a id="3058" class="Symbol">(</a><a id="3059" href="VecMat.html#3059" class="Bound">A</a> <a id="3061" class="Symbol">:</a> <a id="3063" class="PrimitiveType">Set</a> <a id="3067" href="VecMat.html#2624" class="Generalizable">a</a><a id="3068" class="Symbol">)</a> <a id="3070" class="Symbol">:</a> <a id="3072" class="Symbol">(</a><a id="3073" href="VecMat.html#3073" class="Bound">n</a> <a id="3075" class="Symbol">:</a> <a id="3077" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a><a id="3078" class="Symbol">)</a> <a id="3080" class="Symbol">→</a> <a id="3082" class="PrimitiveType">Set</a> <a id="3086" href="VecMat.html#3067" class="Bound">a</a> <a id="3088" class="Keyword">where</a>
    <a id="Naïve.Vec.[]"></a><a id="3098" href="VecMat.html#3098" class="InductiveConstructor">[]</a> <a id="3101" class="Symbol">:</a> <a id="3103" href="VecMat.html#3054" class="Datatype">Vec</a> <a id="3107" href="VecMat.html#3059" class="Bound">A</a> <a id="3109" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a>
    <a id="Naïve.Vec._∷_"></a><a id="3118" href="VecMat.html#3118" class="InductiveConstructor Operator">_∷_</a> <a id="3122" class="Symbol">:</a> <a id="3124" href="VecMat.html#3059" class="Bound">A</a> <a id="3126" class="Symbol">→</a> <a id="3128" href="VecMat.html#3054" class="Datatype">Vec</a> <a id="3132" href="VecMat.html#3059" class="Bound">A</a> <a id="3134" href="VecMat.html#2731" class="Generalizable">n</a> <a id="3136" class="Symbol">→</a> <a id="3138" href="VecMat.html#3054" class="Datatype">Vec</a> <a id="3142" href="VecMat.html#3059" class="Bound">A</a> <a id="3144" class="Symbol">(</a><a id="3145" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="3149" href="VecMat.html#2731" class="Generalizable">n</a><a id="3150" class="Symbol">)</a>
</pre>
<p>These are lists with a specified length. At a technical level, <code>Vec</code> is an inductive type family being constrained by the inductive structure of a natural number <code>n</code>. This means that any function we write out of a <code>Vec</code> will be by induction on the vector’s structure.</p>
<p>We can define matrices as vectors of row vectors.</p>
<pre class="Agda">  <a id="Naïve.Mat"></a><a id="3487" href="VecMat.html#3487" class="Function">Mat</a> <a id="3491" class="Symbol">:</a> <a id="3493" class="Symbol">(</a><a id="3494" href="VecMat.html#3494" class="Bound">A</a> <a id="3496" class="Symbol">:</a> <a id="3498" class="PrimitiveType">Set</a> <a id="3502" href="VecMat.html#2624" class="Generalizable">a</a><a id="3503" class="Symbol">)</a> <a id="3505" class="Symbol">(</a><a id="3506" href="VecMat.html#3506" class="Bound">m</a> <a id="3508" href="VecMat.html#3508" class="Bound">n</a> <a id="3510" class="Symbol">:</a> <a id="3512" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a><a id="3513" class="Symbol">)</a> <a id="3515" class="Symbol">→</a> <a id="3517" class="PrimitiveType">Set</a> <a id="3521" href="VecMat.html#2624" class="Generalizable">a</a>
  <a id="3525" href="VecMat.html#3487" class="Function">Mat</a> <a id="3529" href="VecMat.html#3529" class="Bound">A</a> <a id="3531" href="VecMat.html#3531" class="Bound">m</a> <a id="3533" href="VecMat.html#3533" class="Bound">n</a> <a id="3535" class="Symbol">=</a> <a id="3537" href="VecMat.html#3054" class="Datatype">Vec</a> <a id="3541" class="Symbol">(</a><a id="3542" href="VecMat.html#3054" class="Datatype">Vec</a> <a id="3546" href="VecMat.html#3529" class="Bound">A</a> <a id="3548" href="VecMat.html#3533" class="Bound">n</a><a id="3549" class="Symbol">)</a> <a id="3551" href="VecMat.html#3531" class="Bound">m</a>
</pre>
<p>We will also need to lift relations pointwise to vectors, mainly to talk about equivalence. For the sake of code reuse, we will take a heterogeneous definition.</p>
<pre class="Agda">  <a id="3730" class="Keyword">data</a> <a id="Naïve.Pw"></a><a id="3735" href="VecMat.html#3735" class="Datatype">Pw</a> <a id="3738" class="Symbol">(</a><a id="3739" href="VecMat.html#3739" class="Bound">R</a> <a id="3741" class="Symbol">:</a> <a id="3743" href="Relation.Binary.Core.html#955" class="Function">REL</a> <a id="3747" href="VecMat.html#2651" class="Generalizable">A</a> <a id="3749" href="VecMat.html#2663" class="Generalizable">B</a> <a id="3751" href="VecMat.html#2639" class="Generalizable">ℓ</a><a id="3752" class="Symbol">)</a> <a id="3754" class="Symbol">:</a> <a id="3756" href="Relation.Binary.Core.html#955" class="Function">REL</a> <a id="3760" class="Symbol">(</a><a id="3761" href="VecMat.html#3054" class="Datatype">Vec</a> <a id="3765" href="VecMat.html#3747" class="Bound">A</a> <a id="3767" href="VecMat.html#2731" class="Generalizable">n</a><a id="3768" class="Symbol">)</a> <a id="3770" class="Symbol">(</a><a id="3771" href="VecMat.html#3054" class="Datatype">Vec</a> <a id="3775" href="VecMat.html#3749" class="Bound">B</a> <a id="3777" href="VecMat.html#2731" class="Generalizable">n</a><a id="3778" class="Symbol">)</a> <a id="3780" href="VecMat.html#3751" class="Bound">ℓ</a> <a id="3782" class="Keyword">where</a>
    <a id="Naïve.Pw.[]"></a><a id="3792" href="VecMat.html#3792" class="InductiveConstructor">[]</a> <a id="3795" class="Symbol">:</a> <a id="3797" href="VecMat.html#3735" class="Datatype">Pw</a> <a id="3800" href="VecMat.html#3739" class="Bound">R</a> <a id="3802" href="VecMat.html#3098" class="InductiveConstructor">[]</a> <a id="3805" href="VecMat.html#3098" class="InductiveConstructor">[]</a>
    <a id="Naïve.Pw._∷_"></a><a id="3812" href="VecMat.html#3812" class="InductiveConstructor Operator">_∷_</a> <a id="3816" class="Symbol">:</a> <a id="3818" class="Symbol">∀</a> <a id="3820" class="Symbol">{</a><a id="3821" href="VecMat.html#3821" class="Bound">x</a> <a id="3823" href="VecMat.html#3823" class="Bound">y</a> <a id="3825" href="VecMat.html#3825" class="Bound">xs</a> <a id="3828" href="VecMat.html#3828" class="Bound">ys</a><a id="3830" class="Symbol">}</a> <a id="3832" class="Symbol">→</a> <a id="3834" href="VecMat.html#3739" class="Bound">R</a> <a id="3836" href="VecMat.html#3821" class="Bound">x</a> <a id="3838" href="VecMat.html#3823" class="Bound">y</a> <a id="3840" class="Symbol">→</a> <a id="3842" href="VecMat.html#3735" class="Datatype">Pw</a> <a id="3845" href="VecMat.html#3739" class="Bound">R</a> <a id="3847" class="Symbol">{</a><a id="3848" class="Argument">n</a> <a id="3850" class="Symbol">=</a> <a id="3852" href="VecMat.html#2731" class="Generalizable">n</a><a id="3853" class="Symbol">}</a> <a id="3855" href="VecMat.html#3825" class="Bound">xs</a> <a id="3858" href="VecMat.html#3828" class="Bound">ys</a> <a id="3861" class="Symbol">→</a> <a id="3863" href="VecMat.html#3735" class="Datatype">Pw</a> <a id="3866" href="VecMat.html#3739" class="Bound">R</a> <a id="3868" class="Symbol">(</a><a id="3869" href="VecMat.html#3821" class="Bound">x</a> <a id="3871" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="3873" href="VecMat.html#3825" class="Bound">xs</a><a id="3875" class="Symbol">)</a> <a id="3877" class="Symbol">(</a><a id="3878" href="VecMat.html#3823" class="Bound">y</a> <a id="3880" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="3882" href="VecMat.html#3828" class="Bound">ys</a><a id="3884" class="Symbol">)</a>
</pre>
<!--
<pre class="Agda">  <a id="Naïve.Pw-refl"></a><a id="3906" href="VecMat.html#3906" class="Function">Pw-refl</a> <a id="3914" class="Symbol">:</a> <a id="3916" class="Symbol">{</a><a id="3917" href="VecMat.html#3917" class="Bound">R</a> <a id="3919" class="Symbol">:</a> <a id="3921" href="Relation.Binary.Core.html#1071" class="Function">Rel</a> <a id="3925" href="VecMat.html#2651" class="Generalizable">A</a> <a id="3927" href="VecMat.html#2639" class="Generalizable">ℓ</a><a id="3928" class="Symbol">}</a> <a id="3930" class="Symbol">→</a> <a id="3932" href="Relation.Binary.Core.html#2321" class="Function">Reflexive</a> <a id="3942" href="VecMat.html#3917" class="Bound">R</a> <a id="3944" class="Symbol">→</a> <a id="3946" href="Relation.Binary.Core.html#2321" class="Function">Reflexive</a> <a id="3956" class="Symbol">(</a><a id="3957" href="VecMat.html#3735" class="Datatype">Pw</a> <a id="3960" href="VecMat.html#3917" class="Bound">R</a> <a id="3962" class="Symbol">{</a><a id="3963" class="Argument">n</a> <a id="3965" class="Symbol">=</a> <a id="3967" href="VecMat.html#2731" class="Generalizable">n</a><a id="3968" class="Symbol">})</a>
  <a id="3973" href="VecMat.html#3906" class="Function">Pw-refl</a> <a id="3981" href="VecMat.html#3981" class="Bound">r</a> <a id="3983" class="Symbol">{</a><a id="3984" href="VecMat.html#3098" class="InductiveConstructor">[]</a><a id="3986" class="Symbol">}</a> <a id="3988" class="Symbol">=</a> <a id="3990" href="VecMat.html#3792" class="InductiveConstructor">[]</a>
  <a id="3995" href="VecMat.html#3906" class="Function">Pw-refl</a> <a id="4003" href="VecMat.html#4003" class="Bound">r</a> <a id="4005" class="Symbol">{</a><a id="4006" href="VecMat.html#4006" class="Bound">x</a> <a id="4008" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="4010" href="VecMat.html#4010" class="Bound">xs</a><a id="4012" class="Symbol">}</a> <a id="4014" class="Symbol">=</a> <a id="4016" href="VecMat.html#4003" class="Bound">r</a> <a id="4018" href="VecMat.html#3812" class="InductiveConstructor Operator">∷</a> <a id="4020" href="VecMat.html#3906" class="Function">Pw-refl</a> <a id="4028" href="VecMat.html#4003" class="Bound">r</a> <a id="4030" class="Symbol">{</a><a id="4031" href="VecMat.html#4010" class="Bound">xs</a><a id="4033" class="Symbol">}</a>

  <a id="Naïve.Pw-sym"></a><a id="4038" href="VecMat.html#4038" class="Function">Pw-sym</a> <a id="4045" class="Symbol">:</a> <a id="4047" class="Symbol">{</a><a id="4048" href="VecMat.html#4048" class="Bound">R</a> <a id="4050" class="Symbol">:</a> <a id="4052" href="Relation.Binary.Core.html#1071" class="Function">Rel</a> <a id="4056" href="VecMat.html#2651" class="Generalizable">A</a> <a id="4058" href="VecMat.html#2639" class="Generalizable">ℓ</a><a id="4059" class="Symbol">}</a> <a id="4061" class="Symbol">→</a> <a id="4063" href="Relation.Binary.Core.html#2480" class="Function">Symmetric</a> <a id="4073" href="VecMat.html#4048" class="Bound">R</a> <a id="4075" class="Symbol">→</a> <a id="4077" href="Relation.Binary.Core.html#2480" class="Function">Symmetric</a> <a id="4087" class="Symbol">(</a><a id="4088" href="VecMat.html#3735" class="Datatype">Pw</a> <a id="4091" href="VecMat.html#4048" class="Bound">R</a> <a id="4093" class="Symbol">{</a><a id="4094" class="Argument">n</a> <a id="4096" class="Symbol">=</a> <a id="4098" href="VecMat.html#2731" class="Generalizable">n</a><a id="4099" class="Symbol">})</a>
  <a id="4104" href="VecMat.html#4038" class="Function">Pw-sym</a> <a id="4111" href="VecMat.html#4111" class="Bound">s</a> <a id="4113" href="VecMat.html#3792" class="InductiveConstructor">[]</a> <a id="4116" class="Symbol">=</a> <a id="4118" href="VecMat.html#3792" class="InductiveConstructor">[]</a>
  <a id="4123" href="VecMat.html#4038" class="Function">Pw-sym</a> <a id="4130" href="VecMat.html#4130" class="Bound">s</a> <a id="4132" class="Symbol">(</a><a id="4133" href="VecMat.html#4133" class="Bound">xy</a> <a id="4136" href="VecMat.html#3812" class="InductiveConstructor Operator">∷</a> <a id="4138" href="VecMat.html#4138" class="Bound">xsys</a><a id="4142" class="Symbol">)</a> <a id="4144" class="Symbol">=</a> <a id="4146" href="VecMat.html#4130" class="Bound">s</a> <a id="4148" href="VecMat.html#4133" class="Bound">xy</a> <a id="4151" href="VecMat.html#3812" class="InductiveConstructor Operator">∷</a> <a id="4153" href="VecMat.html#4038" class="Function">Pw-sym</a> <a id="4160" href="VecMat.html#4130" class="Bound">s</a> <a id="4162" href="VecMat.html#4138" class="Bound">xsys</a>

  <a id="Naïve.Pw-trans"></a><a id="4170" href="VecMat.html#4170" class="Function">Pw-trans</a> <a id="4179" class="Symbol">:</a> <a id="4181" class="Symbol">{</a><a id="4182" href="VecMat.html#4182" class="Bound">R</a> <a id="4184" class="Symbol">:</a> <a id="4186" href="Relation.Binary.Core.html#1071" class="Function">Rel</a> <a id="4190" href="VecMat.html#2651" class="Generalizable">A</a> <a id="4192" href="VecMat.html#2639" class="Generalizable">ℓ</a><a id="4193" class="Symbol">}</a> <a id="4195" class="Symbol">→</a> <a id="4197" href="Relation.Binary.Core.html#2848" class="Function">Transitive</a> <a id="4208" href="VecMat.html#4182" class="Bound">R</a> <a id="4210" class="Symbol">→</a> <a id="4212" href="Relation.Binary.Core.html#2848" class="Function">Transitive</a> <a id="4223" class="Symbol">(</a><a id="4224" href="VecMat.html#3735" class="Datatype">Pw</a> <a id="4227" href="VecMat.html#4182" class="Bound">R</a> <a id="4229" class="Symbol">{</a><a id="4230" class="Argument">n</a> <a id="4232" class="Symbol">=</a> <a id="4234" href="VecMat.html#2731" class="Generalizable">n</a><a id="4235" class="Symbol">})</a>
  <a id="4240" href="VecMat.html#4170" class="Function">Pw-trans</a> <a id="4249" href="VecMat.html#4249" class="Bound">t</a> <a id="4251" href="VecMat.html#3792" class="InductiveConstructor">[]</a> <a id="4254" href="VecMat.html#3792" class="InductiveConstructor">[]</a> <a id="4257" class="Symbol">=</a> <a id="4259" href="VecMat.html#3792" class="InductiveConstructor">[]</a>
  <a id="4264" href="VecMat.html#4170" class="Function">Pw-trans</a> <a id="4273" href="VecMat.html#4273" class="Bound">t</a> <a id="4275" class="Symbol">(</a><a id="4276" href="VecMat.html#4276" class="Bound">xy</a> <a id="4279" href="VecMat.html#3812" class="InductiveConstructor Operator">∷</a> <a id="4281" href="VecMat.html#4281" class="Bound">xsys</a><a id="4285" class="Symbol">)</a> <a id="4287" class="Symbol">(</a><a id="4288" href="VecMat.html#4288" class="Bound">yz</a> <a id="4291" href="VecMat.html#3812" class="InductiveConstructor Operator">∷</a> <a id="4293" href="VecMat.html#4293" class="Bound">yszs</a><a id="4297" class="Symbol">)</a> <a id="4299" class="Symbol">=</a> <a id="4301" href="VecMat.html#4273" class="Bound">t</a> <a id="4303" href="VecMat.html#4276" class="Bound">xy</a> <a id="4306" href="VecMat.html#4288" class="Bound">yz</a> <a id="4309" href="VecMat.html#3812" class="InductiveConstructor Operator">∷</a> <a id="4311" href="VecMat.html#4170" class="Function">Pw-trans</a> <a id="4320" href="VecMat.html#4273" class="Bound">t</a> <a id="4322" href="VecMat.html#4281" class="Bound">xsys</a> <a id="4327" href="VecMat.html#4293" class="Bound">yszs</a>

  <a id="Naïve.Pw-setoid"></a><a id="4335" href="VecMat.html#4335" class="Function">Pw-setoid</a> <a id="4345" class="Symbol">:</a> <a id="4347" href="Relation.Binary.html#1970" class="Record">Setoid</a> <a id="4354" href="VecMat.html#2634" class="Generalizable">c</a> <a id="4356" href="VecMat.html#2639" class="Generalizable">ℓ</a> <a id="4358" class="Symbol">→</a> <a id="4360" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="4362" class="Symbol">→</a> <a id="4364" href="Relation.Binary.html#1970" class="Record">Setoid</a> <a id="4371" href="VecMat.html#2634" class="Generalizable">c</a> <a id="4373" href="VecMat.html#2639" class="Generalizable">ℓ</a>
  <a id="4377" href="VecMat.html#4335" class="Function">Pw-setoid</a> <a id="4387" href="VecMat.html#4387" class="Bound">S</a> <a id="4389" href="VecMat.html#4389" class="Bound">n</a> <a id="4391" class="Symbol">=</a> <a id="4393" class="Keyword">record</a>
    <a id="4404" class="Symbol">{</a> <a id="4406" href="Relation.Binary.html#2033" class="Field">Carrier</a> <a id="4414" class="Symbol">=</a> <a id="4416" href="VecMat.html#3054" class="Datatype">Vec</a> <a id="4420" href="Relation.Binary.html#2033" class="Function">Carrier</a> <a id="4428" href="VecMat.html#4389" class="Bound">n</a>
    <a id="4434" class="Symbol">;</a> <a id="4436" href="Relation.Binary.html#2059" class="Field Operator">_≈_</a> <a id="4440" class="Symbol">=</a> <a id="4442" href="VecMat.html#3735" class="Datatype">Pw</a> <a id="4445" href="Relation.Binary.html#2059" class="Function Operator">_≈_</a>
    <a id="4453" class="Symbol">;</a> <a id="4455" href="Relation.Binary.html#2093" class="Field">isEquivalence</a> <a id="4469" class="Symbol">=</a> <a id="4471" class="Keyword">record</a>
      <a id="4484" class="Symbol">{</a> <a id="4486" href="Relation.Binary.Core.html#7020" class="Field">refl</a> <a id="4491" class="Symbol">=</a> <a id="4493" href="VecMat.html#3906" class="Function">Pw-refl</a> <a id="4501" href="Relation.Binary.Core.html#7020" class="Function">refl</a>
      <a id="4512" class="Symbol">;</a> <a id="4514" href="Relation.Binary.Core.html#7046" class="Field">sym</a> <a id="4518" class="Symbol">=</a> <a id="4520" href="VecMat.html#4038" class="Function">Pw-sym</a> <a id="4527" href="Relation.Binary.Core.html#7046" class="Function">sym</a>
      <a id="4537" class="Symbol">;</a> <a id="4539" href="Relation.Binary.Core.html#7072" class="Field">trans</a> <a id="4545" class="Symbol">=</a> <a id="4547" href="VecMat.html#4170" class="Function">Pw-trans</a> <a id="4556" href="Relation.Binary.Core.html#7072" class="Function">trans</a>
      <a id="4568" class="Symbol">}</a>
    <a id="4574" class="Symbol">}</a> <a id="4576" class="Keyword">where</a> <a id="4582" class="Keyword">open</a> <a id="4587" href="Relation.Binary.html#1970" class="Module">Setoid</a> <a id="4594" href="VecMat.html#4387" class="Bound">S</a>
</pre>-->
<p>Addition and the zero matrix will follow from the applicative structure of <code>λ A → Vec A n</code> (that is, <code>zip</code> and <code>replicate</code>, respectively). With a few more standard list functions, we will be able to define the identity matrix and matrix multiplication.</p>
<!--
<pre class="Agda">  <a id="4874" class="Keyword">infixr</a> <a id="4881" class="Number">5</a> <a id="4883" href="VecMat.html#4988" class="Function Operator">_++_</a> <a id="4888" href="VecMat.html#6099" class="Function Operator">_Pw-++_</a>

  <a id="Naïve.map"></a><a id="4899" href="VecMat.html#4899" class="Function">map</a> <a id="4903" class="Symbol">:</a> <a id="4905" class="Symbol">(</a><a id="4906" href="VecMat.html#2651" class="Generalizable">A</a> <a id="4908" class="Symbol">→</a> <a id="4910" href="VecMat.html#2663" class="Generalizable">B</a><a id="4911" class="Symbol">)</a> <a id="4913" class="Symbol">→</a> <a id="4915" class="Symbol">(</a><a id="4916" href="VecMat.html#3054" class="Datatype">Vec</a> <a id="4920" href="VecMat.html#2651" class="Generalizable">A</a> <a id="4922" href="VecMat.html#2731" class="Generalizable">n</a> <a id="4924" class="Symbol">→</a> <a id="4926" href="VecMat.html#3054" class="Datatype">Vec</a> <a id="4930" href="VecMat.html#2663" class="Generalizable">B</a> <a id="4932" href="VecMat.html#2731" class="Generalizable">n</a><a id="4933" class="Symbol">)</a>
  <a id="4937" href="VecMat.html#4899" class="Function">map</a> <a id="4941" href="VecMat.html#4941" class="Bound">f</a> <a id="4943" href="VecMat.html#3098" class="InductiveConstructor">[]</a> <a id="4946" class="Symbol">=</a> <a id="4948" href="VecMat.html#3098" class="InductiveConstructor">[]</a>
  <a id="4953" href="VecMat.html#4899" class="Function">map</a> <a id="4957" href="VecMat.html#4957" class="Bound">f</a> <a id="4959" class="Symbol">(</a><a id="4960" href="VecMat.html#4960" class="Bound">x</a> <a id="4962" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="4964" href="VecMat.html#4964" class="Bound">xs</a><a id="4966" class="Symbol">)</a> <a id="4968" class="Symbol">=</a> <a id="4970" href="VecMat.html#4957" class="Bound">f</a> <a id="4972" href="VecMat.html#4960" class="Bound">x</a> <a id="4974" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="4976" href="VecMat.html#4899" class="Function">map</a> <a id="4980" href="VecMat.html#4957" class="Bound">f</a> <a id="4982" href="VecMat.html#4964" class="Bound">xs</a>

  <a id="Naïve._++_"></a><a id="4988" href="VecMat.html#4988" class="Function Operator">_++_</a> <a id="4993" class="Symbol">:</a> <a id="4995" href="VecMat.html#3054" class="Datatype">Vec</a> <a id="4999" href="VecMat.html#2651" class="Generalizable">A</a> <a id="5001" href="VecMat.html#2729" class="Generalizable">m</a> <a id="5003" class="Symbol">→</a> <a id="5005" href="VecMat.html#3054" class="Datatype">Vec</a> <a id="5009" href="VecMat.html#2651" class="Generalizable">A</a> <a id="5011" href="VecMat.html#2731" class="Generalizable">n</a> <a id="5013" class="Symbol">→</a> <a id="5015" href="VecMat.html#3054" class="Datatype">Vec</a> <a id="5019" href="VecMat.html#2651" class="Generalizable">A</a> <a id="5021" class="Symbol">(</a><a id="5022" href="VecMat.html#2729" class="Generalizable">m</a> <a id="5024" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">N.+</a> <a id="5028" href="VecMat.html#2731" class="Generalizable">n</a><a id="5029" class="Symbol">)</a>
  <a id="5033" href="VecMat.html#3098" class="InductiveConstructor">[]</a> <a id="5036" href="VecMat.html#4988" class="Function Operator">++</a> <a id="5039" href="VecMat.html#5039" class="Bound">ys</a> <a id="5042" class="Symbol">=</a> <a id="5044" href="VecMat.html#5039" class="Bound">ys</a>
  <a id="5049" class="Symbol">(</a><a id="5050" href="VecMat.html#5050" class="Bound">x</a> <a id="5052" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="5054" href="VecMat.html#5054" class="Bound">xs</a><a id="5056" class="Symbol">)</a> <a id="5058" href="VecMat.html#4988" class="Function Operator">++</a> <a id="5061" href="VecMat.html#5061" class="Bound">ys</a> <a id="5064" class="Symbol">=</a> <a id="5066" href="VecMat.html#5050" class="Bound">x</a> <a id="5068" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="5070" href="VecMat.html#5054" class="Bound">xs</a> <a id="5073" href="VecMat.html#4988" class="Function Operator">++</a> <a id="5076" href="VecMat.html#5061" class="Bound">ys</a>

  <a id="Naïve.replicate"></a><a id="5082" href="VecMat.html#5082" class="Function">replicate</a> <a id="5092" class="Symbol">:</a> <a id="5094" href="VecMat.html#2651" class="Generalizable">A</a> <a id="5096" class="Symbol">→</a> <a id="5098" href="VecMat.html#3054" class="Datatype">Vec</a> <a id="5102" href="VecMat.html#2651" class="Generalizable">A</a> <a id="5104" href="VecMat.html#2731" class="Generalizable">n</a>
  <a id="5108" href="VecMat.html#5082" class="Function">replicate</a> <a id="5118" class="Symbol">{</a><a id="5119" class="Argument">n</a> <a id="5121" class="Symbol">=</a> <a id="5123" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a><a id="5127" class="Symbol">}</a> <a id="5129" href="VecMat.html#5129" class="Bound">x</a> <a id="5131" class="Symbol">=</a> <a id="5133" href="VecMat.html#3098" class="InductiveConstructor">[]</a>
  <a id="5138" href="VecMat.html#5082" class="Function">replicate</a> <a id="5148" class="Symbol">{</a><a id="5149" class="Argument">n</a> <a id="5151" class="Symbol">=</a> <a id="5153" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="5157" href="VecMat.html#5157" class="Bound">n</a><a id="5158" class="Symbol">}</a> <a id="5160" href="VecMat.html#5160" class="Bound">x</a> <a id="5162" class="Symbol">=</a> <a id="5164" href="VecMat.html#5160" class="Bound">x</a> <a id="5166" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="5168" href="VecMat.html#5082" class="Function">replicate</a> <a id="5178" href="VecMat.html#5160" class="Bound">x</a>

  <a id="Naïve.zip"></a><a id="5183" href="VecMat.html#5183" class="Function">zip</a> <a id="5187" class="Symbol">:</a> <a id="5189" class="Symbol">(</a><a id="5190" href="VecMat.html#2651" class="Generalizable">A</a> <a id="5192" class="Symbol">→</a> <a id="5194" href="VecMat.html#2663" class="Generalizable">B</a> <a id="5196" class="Symbol">→</a> <a id="5198" href="VecMat.html#2675" class="Generalizable">C</a><a id="5199" class="Symbol">)</a> <a id="5201" class="Symbol">→</a> <a id="5203" class="Symbol">(</a><a id="5204" href="VecMat.html#3054" class="Datatype">Vec</a> <a id="5208" href="VecMat.html#2651" class="Generalizable">A</a> <a id="5210" href="VecMat.html#2731" class="Generalizable">n</a> <a id="5212" class="Symbol">→</a> <a id="5214" href="VecMat.html#3054" class="Datatype">Vec</a> <a id="5218" href="VecMat.html#2663" class="Generalizable">B</a> <a id="5220" href="VecMat.html#2731" class="Generalizable">n</a> <a id="5222" class="Symbol">→</a> <a id="5224" href="VecMat.html#3054" class="Datatype">Vec</a> <a id="5228" href="VecMat.html#2675" class="Generalizable">C</a> <a id="5230" href="VecMat.html#2731" class="Generalizable">n</a><a id="5231" class="Symbol">)</a>
  <a id="5235" href="VecMat.html#5183" class="Function">zip</a> <a id="5239" href="VecMat.html#5239" class="Bound">f</a> <a id="5241" href="VecMat.html#3098" class="InductiveConstructor">[]</a> <a id="5244" href="VecMat.html#3098" class="InductiveConstructor">[]</a> <a id="5247" class="Symbol">=</a> <a id="5249" href="VecMat.html#3098" class="InductiveConstructor">[]</a>
  <a id="5254" href="VecMat.html#5183" class="Function">zip</a> <a id="5258" href="VecMat.html#5258" class="Bound">f</a> <a id="5260" class="Symbol">(</a><a id="5261" href="VecMat.html#5261" class="Bound">x</a> <a id="5263" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="5265" href="VecMat.html#5265" class="Bound">xs</a><a id="5267" class="Symbol">)</a> <a id="5269" class="Symbol">(</a><a id="5270" href="VecMat.html#5270" class="Bound">y</a> <a id="5272" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="5274" href="VecMat.html#5274" class="Bound">ys</a><a id="5276" class="Symbol">)</a> <a id="5278" class="Symbol">=</a> <a id="5280" href="VecMat.html#5258" class="Bound">f</a> <a id="5282" href="VecMat.html#5261" class="Bound">x</a> <a id="5284" href="VecMat.html#5270" class="Bound">y</a> <a id="5286" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="5288" href="VecMat.html#5183" class="Function">zip</a> <a id="5292" href="VecMat.html#5258" class="Bound">f</a> <a id="5294" href="VecMat.html#5265" class="Bound">xs</a> <a id="5297" href="VecMat.html#5274" class="Bound">ys</a>
</pre>-->
<pre class="Agda">  <a id="Naïve.outer"></a><a id="5319" href="VecMat.html#5319" class="Function">outer</a> <a id="5325" class="Symbol">:</a> <a id="5327" class="Symbol">(</a><a id="5328" href="VecMat.html#2651" class="Generalizable">A</a> <a id="5330" class="Symbol">→</a> <a id="5332" href="VecMat.html#2663" class="Generalizable">B</a> <a id="5334" class="Symbol">→</a> <a id="5336" href="VecMat.html#2675" class="Generalizable">C</a><a id="5337" class="Symbol">)</a> <a id="5339" class="Symbol">→</a> <a id="5341" class="Symbol">(</a><a id="5342" href="VecMat.html#3054" class="Datatype">Vec</a> <a id="5346" href="VecMat.html#2651" class="Generalizable">A</a> <a id="5348" href="VecMat.html#2729" class="Generalizable">m</a> <a id="5350" class="Symbol">→</a> <a id="5352" href="VecMat.html#3054" class="Datatype">Vec</a> <a id="5356" href="VecMat.html#2663" class="Generalizable">B</a> <a id="5358" href="VecMat.html#2731" class="Generalizable">n</a> <a id="5360" class="Symbol">→</a> <a id="5362" href="VecMat.html#3487" class="Function">Mat</a> <a id="5366" href="VecMat.html#2675" class="Generalizable">C</a> <a id="5368" href="VecMat.html#2729" class="Generalizable">m</a> <a id="5370" href="VecMat.html#2731" class="Generalizable">n</a><a id="5371" class="Symbol">)</a>
  <a id="5375" href="VecMat.html#5319" class="Function">outer</a> <a id="5381" href="VecMat.html#5381" class="Bound">f</a> <a id="5383" href="VecMat.html#3098" class="InductiveConstructor">[]</a> <a id="5386" href="VecMat.html#5386" class="Bound">ys</a> <a id="5389" class="Symbol">=</a> <a id="5391" href="VecMat.html#3098" class="InductiveConstructor">[]</a>
  <a id="5396" href="VecMat.html#5319" class="Function">outer</a> <a id="5402" href="VecMat.html#5402" class="Bound">f</a> <a id="5404" class="Symbol">(</a><a id="5405" href="VecMat.html#5405" class="Bound">x</a> <a id="5407" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="5409" href="VecMat.html#5409" class="Bound">xs</a><a id="5411" class="Symbol">)</a> <a id="5413" href="VecMat.html#5413" class="Bound">ys</a> <a id="5416" class="Symbol">=</a> <a id="5418" href="VecMat.html#4899" class="Function">map</a> <a id="5422" class="Symbol">(</a><a id="5423" href="VecMat.html#5402" class="Bound">f</a> <a id="5425" href="VecMat.html#5405" class="Bound">x</a><a id="5426" class="Symbol">)</a> <a id="5428" href="VecMat.html#5413" class="Bound">ys</a> <a id="5431" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="5433" href="VecMat.html#5319" class="Function">outer</a> <a id="5439" href="VecMat.html#5402" class="Bound">f</a> <a id="5441" href="VecMat.html#5409" class="Bound">xs</a> <a id="5444" href="VecMat.html#5413" class="Bound">ys</a>
</pre>
<p>We will multiply matrices by taking the <a href="https://en.wikipedia.org/wiki/Outer_product">outer product</a> of each column/row pair, giving a collection of matrices, and then summing these matrices together. This is why we define the function <code>outer</code>.</p>
<!--
<pre class="Agda">  <a id="Naïve.pw"></a><a id="5713" href="VecMat.html#5713" class="Function">pw</a> <a id="5716" class="Symbol">:</a> <a id="5718" class="Symbol">∀</a> <a id="5720" class="Symbol">{</a><a id="5721" href="VecMat.html#5721" class="Bound">r</a> <a id="5723" href="VecMat.html#5723" class="Bound">s</a><a id="5724" class="Symbol">}</a> <a id="5726" class="Symbol">{</a><a id="5727" href="VecMat.html#5727" class="Bound">R</a> <a id="5729" class="Symbol">:</a> <a id="5731" href="Relation.Binary.Core.html#955" class="Function">REL</a> <a id="5735" href="VecMat.html#2651" class="Generalizable">A</a> <a id="5737" href="VecMat.html#2663" class="Generalizable">B</a> <a id="5739" href="VecMat.html#5721" class="Bound">r</a><a id="5740" class="Symbol">}</a> <a id="5742" class="Symbol">{</a><a id="5743" href="VecMat.html#5743" class="Bound">S</a> <a id="5745" class="Symbol">:</a> <a id="5747" href="Relation.Binary.Core.html#955" class="Function">REL</a> <a id="5751" href="VecMat.html#2651" class="Generalizable">A</a> <a id="5753" href="VecMat.html#2663" class="Generalizable">B</a> <a id="5755" href="VecMat.html#5723" class="Bound">s</a><a id="5756" class="Symbol">}</a> <a id="5758" class="Symbol">→</a> <a id="5760" href="VecMat.html#5727" class="Bound">R</a> <a id="5762" href="Relation.Binary.Core.html#1383" class="Function Operator">⇒</a> <a id="5764" href="VecMat.html#5743" class="Bound">S</a> <a id="5766" class="Symbol">→</a> <a id="5768" href="VecMat.html#3735" class="Datatype">Pw</a> <a id="5771" href="VecMat.html#5727" class="Bound">R</a> <a id="5773" class="Symbol">{</a><a id="5774" class="Argument">n</a> <a id="5776" class="Symbol">=</a> <a id="5778" href="VecMat.html#2731" class="Generalizable">n</a><a id="5779" class="Symbol">}</a> <a id="5781" href="Relation.Binary.Core.html#1383" class="Function Operator">⇒</a> <a id="5783" href="VecMat.html#3735" class="Datatype">Pw</a> <a id="5786" href="VecMat.html#5743" class="Bound">S</a>
  <a id="5790" href="VecMat.html#5713" class="Function">pw</a> <a id="5793" href="VecMat.html#5793" class="Bound">p</a> <a id="5795" href="VecMat.html#3792" class="InductiveConstructor">[]</a> <a id="5798" class="Symbol">=</a> <a id="5800" href="VecMat.html#3792" class="InductiveConstructor">[]</a>
  <a id="5805" href="VecMat.html#5713" class="Function">pw</a> <a id="5808" href="VecMat.html#5808" class="Bound">p</a> <a id="5810" class="Symbol">(</a><a id="5811" href="VecMat.html#5811" class="Bound">r</a> <a id="5813" href="VecMat.html#3812" class="InductiveConstructor Operator">∷</a> <a id="5815" href="VecMat.html#5815" class="Bound">rs</a><a id="5817" class="Symbol">)</a> <a id="5819" class="Symbol">=</a> <a id="5821" href="VecMat.html#5808" class="Bound">p</a> <a id="5823" href="VecMat.html#5811" class="Bound">r</a> <a id="5825" href="VecMat.html#3812" class="InductiveConstructor Operator">∷</a> <a id="5827" href="VecMat.html#5713" class="Function">pw</a> <a id="5830" href="VecMat.html#5808" class="Bound">p</a> <a id="5832" href="VecMat.html#5815" class="Bound">rs</a>

  <a id="Naïve.Pw-map"></a><a id="5838" href="VecMat.html#5838" class="Function">Pw-map</a> <a id="5845" class="Symbol">:</a> <a id="5847" class="Symbol">∀</a> <a id="5849" class="Symbol">{</a><a id="5850" href="VecMat.html#5850" class="Bound">r</a> <a id="5852" href="VecMat.html#5852" class="Bound">s</a><a id="5853" class="Symbol">}</a> <a id="5855" class="Symbol">{</a><a id="5856" href="VecMat.html#5856" class="Bound">f</a> <a id="5858" class="Symbol">:</a> <a id="5860" href="VecMat.html#2651" class="Generalizable">A</a> <a id="5862" class="Symbol">→</a> <a id="5864" href="VecMat.html#2687" class="Generalizable">A′</a><a id="5866" class="Symbol">}</a> <a id="5868" class="Symbol">{</a><a id="5869" href="VecMat.html#5869" class="Bound">g</a> <a id="5871" class="Symbol">:</a> <a id="5873" href="VecMat.html#2663" class="Generalizable">B</a> <a id="5875" class="Symbol">→</a> <a id="5877" href="VecMat.html#2701" class="Generalizable">B′</a><a id="5879" class="Symbol">}</a> <a id="5881" class="Symbol">{</a><a id="5882" href="VecMat.html#5882" class="Bound">R</a> <a id="5884" class="Symbol">:</a> <a id="5886" href="Relation.Binary.Core.html#955" class="Function">REL</a> <a id="5890" href="VecMat.html#2651" class="Generalizable">A</a> <a id="5892" href="VecMat.html#2663" class="Generalizable">B</a> <a id="5894" href="VecMat.html#5850" class="Bound">r</a><a id="5895" class="Symbol">}</a> <a id="5897" class="Symbol">{</a><a id="5898" href="VecMat.html#5898" class="Bound">S</a> <a id="5900" class="Symbol">:</a> <a id="5902" href="Relation.Binary.Core.html#955" class="Function">REL</a> <a id="5906" href="VecMat.html#2687" class="Generalizable">A′</a> <a id="5909" href="VecMat.html#2701" class="Generalizable">B′</a> <a id="5912" href="VecMat.html#5852" class="Bound">s</a><a id="5913" class="Symbol">}</a> <a id="5915" class="Symbol">→</a>
           <a id="5928" class="Symbol">(∀</a> <a id="5931" class="Symbol">{</a><a id="5932" href="VecMat.html#5932" class="Bound">x</a> <a id="5934" href="VecMat.html#5934" class="Bound">y</a><a id="5935" class="Symbol">}</a> <a id="5937" class="Symbol">→</a> <a id="5939" href="VecMat.html#5882" class="Bound">R</a> <a id="5941" href="VecMat.html#5932" class="Bound">x</a> <a id="5943" href="VecMat.html#5934" class="Bound">y</a> <a id="5945" class="Symbol">→</a> <a id="5947" href="VecMat.html#5898" class="Bound">S</a> <a id="5949" class="Symbol">(</a><a id="5950" href="VecMat.html#5856" class="Bound">f</a> <a id="5952" href="VecMat.html#5932" class="Bound">x</a><a id="5953" class="Symbol">)</a> <a id="5955" class="Symbol">(</a><a id="5956" href="VecMat.html#5869" class="Bound">g</a> <a id="5958" href="VecMat.html#5934" class="Bound">y</a><a id="5959" class="Symbol">))</a> <a id="5962" class="Symbol">→</a> <a id="5964" class="Symbol">∀</a> <a id="5966" class="Symbol">{</a><a id="5967" href="VecMat.html#5967" class="Bound">n</a> <a id="5969" href="VecMat.html#5969" class="Bound">xs</a> <a id="5972" href="VecMat.html#5972" class="Bound">ys</a><a id="5974" class="Symbol">}</a> <a id="5976" class="Symbol">→</a>
           <a id="5989" href="VecMat.html#3735" class="Datatype">Pw</a> <a id="5992" href="VecMat.html#5882" class="Bound">R</a> <a id="5994" class="Symbol">{</a><a id="5995" class="Argument">n</a> <a id="5997" class="Symbol">=</a> <a id="5999" href="VecMat.html#5967" class="Bound">n</a><a id="6000" class="Symbol">}</a> <a id="6002" href="VecMat.html#5969" class="Bound">xs</a> <a id="6005" href="VecMat.html#5972" class="Bound">ys</a> <a id="6008" class="Symbol">→</a> <a id="6010" href="VecMat.html#3735" class="Datatype">Pw</a> <a id="6013" href="VecMat.html#5898" class="Bound">S</a> <a id="6015" class="Symbol">(</a><a id="6016" href="VecMat.html#4899" class="Function">map</a> <a id="6020" href="VecMat.html#5856" class="Bound">f</a> <a id="6022" href="VecMat.html#5969" class="Bound">xs</a><a id="6024" class="Symbol">)</a> <a id="6026" class="Symbol">(</a><a id="6027" href="VecMat.html#4899" class="Function">map</a> <a id="6031" href="VecMat.html#5869" class="Bound">g</a> <a id="6033" href="VecMat.html#5972" class="Bound">ys</a><a id="6035" class="Symbol">)</a>
  <a id="6039" href="VecMat.html#5838" class="Function">Pw-map</a> <a id="6046" href="VecMat.html#6046" class="Bound">p</a> <a id="6048" href="VecMat.html#3792" class="InductiveConstructor">[]</a> <a id="6051" class="Symbol">=</a> <a id="6053" href="VecMat.html#3792" class="InductiveConstructor">[]</a>
  <a id="6058" href="VecMat.html#5838" class="Function">Pw-map</a> <a id="6065" href="VecMat.html#6065" class="Bound">p</a> <a id="6067" class="Symbol">(</a><a id="6068" href="VecMat.html#6068" class="Bound">r</a> <a id="6070" href="VecMat.html#3812" class="InductiveConstructor Operator">∷</a> <a id="6072" href="VecMat.html#6072" class="Bound">rs</a><a id="6074" class="Symbol">)</a> <a id="6076" class="Symbol">=</a> <a id="6078" href="VecMat.html#6065" class="Bound">p</a> <a id="6080" href="VecMat.html#6068" class="Bound">r</a> <a id="6082" href="VecMat.html#3812" class="InductiveConstructor Operator">∷</a> <a id="6084" href="VecMat.html#5838" class="Function">Pw-map</a> <a id="6091" href="VecMat.html#6065" class="Bound">p</a> <a id="6093" href="VecMat.html#6072" class="Bound">rs</a>

  <a id="Naïve._Pw-++_"></a><a id="6099" href="VecMat.html#6099" class="Function Operator">_Pw-++_</a> <a id="6107" class="Symbol">:</a> <a id="6109" class="Symbol">∀</a> <a id="6111" class="Symbol">{</a><a id="6112" href="VecMat.html#6112" class="Bound">r</a><a id="6113" class="Symbol">}</a> <a id="6115" class="Symbol">{</a><a id="6116" href="VecMat.html#6116" class="Bound">R</a> <a id="6118" class="Symbol">:</a> <a id="6120" href="Relation.Binary.Core.html#1071" class="Function">Rel</a> <a id="6124" href="VecMat.html#2651" class="Generalizable">A</a> <a id="6126" href="VecMat.html#6112" class="Bound">r</a><a id="6127" class="Symbol">}</a> <a id="6129" class="Symbol">{</a><a id="6130" href="VecMat.html#6130" class="Bound">xs</a> <a id="6133" href="VecMat.html#6133" class="Bound">xs′</a> <a id="6137" href="VecMat.html#6137" class="Bound">ys</a> <a id="6140" href="VecMat.html#6140" class="Bound">ys′</a><a id="6143" class="Symbol">}</a> <a id="6145" class="Symbol">→</a>
            <a id="6159" href="VecMat.html#3735" class="Datatype">Pw</a> <a id="6162" href="VecMat.html#6116" class="Bound">R</a> <a id="6164" class="Symbol">{</a><a id="6165" class="Argument">n</a> <a id="6167" class="Symbol">=</a> <a id="6169" href="VecMat.html#2729" class="Generalizable">m</a><a id="6170" class="Symbol">}</a> <a id="6172" href="VecMat.html#6130" class="Bound">xs</a> <a id="6175" href="VecMat.html#6133" class="Bound">xs′</a> <a id="6179" class="Symbol">→</a> <a id="6181" href="VecMat.html#3735" class="Datatype">Pw</a> <a id="6184" href="VecMat.html#6116" class="Bound">R</a> <a id="6186" class="Symbol">{</a><a id="6187" class="Argument">n</a> <a id="6189" class="Symbol">=</a> <a id="6191" href="VecMat.html#2731" class="Generalizable">n</a><a id="6192" class="Symbol">}</a> <a id="6194" href="VecMat.html#6137" class="Bound">ys</a> <a id="6197" href="VecMat.html#6140" class="Bound">ys′</a> <a id="6201" class="Symbol">→</a>
            <a id="6215" href="VecMat.html#3735" class="Datatype">Pw</a> <a id="6218" href="VecMat.html#6116" class="Bound">R</a> <a id="6220" class="Symbol">(</a><a id="6221" href="VecMat.html#6130" class="Bound">xs</a> <a id="6224" href="VecMat.html#4988" class="Function Operator">++</a> <a id="6227" href="VecMat.html#6137" class="Bound">ys</a><a id="6229" class="Symbol">)</a> <a id="6231" class="Symbol">(</a><a id="6232" href="VecMat.html#6133" class="Bound">xs′</a> <a id="6236" href="VecMat.html#4988" class="Function Operator">++</a> <a id="6239" href="VecMat.html#6140" class="Bound">ys′</a><a id="6242" class="Symbol">)</a>
  <a id="6246" href="VecMat.html#3792" class="InductiveConstructor">[]</a> <a id="6249" href="VecMat.html#6099" class="Function Operator">Pw-++</a> <a id="6255" href="VecMat.html#6255" class="Bound">yrs</a> <a id="6259" class="Symbol">=</a> <a id="6261" href="VecMat.html#6255" class="Bound">yrs</a>
  <a id="6267" class="Symbol">(</a><a id="6268" href="VecMat.html#6268" class="Bound">xr</a> <a id="6271" href="VecMat.html#3812" class="InductiveConstructor Operator">∷</a> <a id="6273" href="VecMat.html#6273" class="Bound">xrs</a><a id="6276" class="Symbol">)</a> <a id="6278" href="VecMat.html#6099" class="Function Operator">Pw-++</a> <a id="6284" href="VecMat.html#6284" class="Bound">yrs</a> <a id="6288" class="Symbol">=</a> <a id="6290" href="VecMat.html#6268" class="Bound">xr</a> <a id="6293" href="VecMat.html#3812" class="InductiveConstructor Operator">∷</a> <a id="6295" href="VecMat.html#6273" class="Bound">xrs</a> <a id="6299" href="VecMat.html#6099" class="Function Operator">Pw-++</a> <a id="6305" href="VecMat.html#6284" class="Bound">yrs</a>

  <a id="Naïve.Pw-replicate"></a><a id="6312" href="VecMat.html#6312" class="Function">Pw-replicate</a> <a id="6325" class="Symbol">:</a> <a id="6327" class="Symbol">∀</a> <a id="6329" class="Symbol">{</a><a id="6330" href="VecMat.html#6330" class="Bound">r</a><a id="6331" class="Symbol">}</a> <a id="6333" class="Symbol">{</a><a id="6334" href="VecMat.html#6334" class="Bound">R</a> <a id="6336" class="Symbol">:</a> <a id="6338" href="Relation.Binary.Core.html#1071" class="Function">Rel</a> <a id="6342" href="VecMat.html#2651" class="Generalizable">A</a> <a id="6344" href="VecMat.html#6330" class="Bound">r</a><a id="6345" class="Symbol">}</a> <a id="6347" class="Symbol">{</a><a id="6348" href="VecMat.html#6348" class="Bound">x</a> <a id="6350" href="VecMat.html#6350" class="Bound">y</a><a id="6351" class="Symbol">}</a> <a id="6353" class="Symbol">→</a>
                 <a id="6372" href="VecMat.html#6334" class="Bound">R</a> <a id="6374" href="VecMat.html#6348" class="Bound">x</a> <a id="6376" href="VecMat.html#6350" class="Bound">y</a> <a id="6378" class="Symbol">→</a> <a id="6380" href="VecMat.html#3735" class="Datatype">Pw</a> <a id="6383" href="VecMat.html#6334" class="Bound">R</a> <a id="6385" class="Symbol">{</a><a id="6386" class="Argument">n</a> <a id="6388" class="Symbol">=</a> <a id="6390" href="VecMat.html#2731" class="Generalizable">n</a><a id="6391" class="Symbol">}</a> <a id="6393" class="Symbol">(</a><a id="6394" href="VecMat.html#5082" class="Function">replicate</a> <a id="6404" href="VecMat.html#6348" class="Bound">x</a><a id="6405" class="Symbol">)</a> <a id="6407" class="Symbol">(</a><a id="6408" href="VecMat.html#5082" class="Function">replicate</a> <a id="6418" href="VecMat.html#6350" class="Bound">y</a><a id="6419" class="Symbol">)</a>
  <a id="6423" href="VecMat.html#6312" class="Function">Pw-replicate</a> <a id="6436" class="Symbol">{</a><a id="6437" class="Argument">n</a> <a id="6439" class="Symbol">=</a> <a id="6441" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a><a id="6445" class="Symbol">}</a> <a id="6447" href="VecMat.html#6447" class="Bound">r</a> <a id="6449" class="Symbol">=</a> <a id="6451" href="VecMat.html#3792" class="InductiveConstructor">[]</a>
  <a id="6456" href="VecMat.html#6312" class="Function">Pw-replicate</a> <a id="6469" class="Symbol">{</a><a id="6470" class="Argument">n</a> <a id="6472" class="Symbol">=</a> <a id="6474" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="6478" href="VecMat.html#6478" class="Bound">n</a><a id="6479" class="Symbol">}</a> <a id="6481" href="VecMat.html#6481" class="Bound">r</a> <a id="6483" class="Symbol">=</a> <a id="6485" href="VecMat.html#6481" class="Bound">r</a> <a id="6487" href="VecMat.html#3812" class="InductiveConstructor Operator">∷</a> <a id="6489" href="VecMat.html#6312" class="Function">Pw-replicate</a> <a id="6502" class="Symbol">{</a><a id="6503" class="Argument">n</a> <a id="6505" class="Symbol">=</a> <a id="6507" href="VecMat.html#6478" class="Bound">n</a><a id="6508" class="Symbol">}</a> <a id="6510" href="VecMat.html#6481" class="Bound">r</a>

  <a id="Naïve.Pw-zip"></a><a id="6515" href="VecMat.html#6515" class="Function">Pw-zip</a> <a id="6522" class="Symbol">:</a>
    <a id="6528" class="Symbol">∀</a> <a id="6530" class="Symbol">{</a><a id="6531" href="VecMat.html#6531" class="Bound">r</a> <a id="6533" href="VecMat.html#6533" class="Bound">s</a> <a id="6535" href="VecMat.html#6535" class="Bound">t</a><a id="6536" class="Symbol">}</a> <a id="6538" class="Symbol">{</a><a id="6539" href="VecMat.html#6539" class="Bound">f</a> <a id="6541" class="Symbol">:</a> <a id="6543" href="VecMat.html#2651" class="Generalizable">A</a> <a id="6545" class="Symbol">→</a> <a id="6547" href="VecMat.html#2663" class="Generalizable">B</a> <a id="6549" class="Symbol">→</a> <a id="6551" href="VecMat.html#2675" class="Generalizable">C</a><a id="6552" class="Symbol">}</a> <a id="6554" class="Symbol">{</a><a id="6555" href="VecMat.html#6555" class="Bound">R</a> <a id="6557" class="Symbol">:</a> <a id="6559" href="Relation.Binary.Core.html#1071" class="Function">Rel</a> <a id="6563" href="VecMat.html#2651" class="Generalizable">A</a> <a id="6565" href="VecMat.html#6531" class="Bound">r</a><a id="6566" class="Symbol">}</a> <a id="6568" class="Symbol">{</a><a id="6569" href="VecMat.html#6569" class="Bound">S</a> <a id="6571" class="Symbol">:</a> <a id="6573" href="Relation.Binary.Core.html#1071" class="Function">Rel</a> <a id="6577" href="VecMat.html#2663" class="Generalizable">B</a> <a id="6579" href="VecMat.html#6533" class="Bound">s</a><a id="6580" class="Symbol">}</a> <a id="6582" class="Symbol">{</a><a id="6583" href="VecMat.html#6583" class="Bound">T</a> <a id="6585" class="Symbol">:</a> <a id="6587" href="Relation.Binary.Core.html#1071" class="Function">Rel</a> <a id="6591" href="VecMat.html#2675" class="Generalizable">C</a> <a id="6593" href="VecMat.html#6535" class="Bound">t</a><a id="6594" class="Symbol">}</a> <a id="6596" class="Symbol">→</a>
    <a id="6602" href="VecMat.html#6539" class="Bound">f</a> <a id="6604" href="Relation.Binary.Core.html#1757" class="Function Operator">Preserves₂</a> <a id="6615" href="VecMat.html#6555" class="Bound">R</a> <a id="6617" href="Relation.Binary.Core.html#1757" class="Function Operator">⟶</a> <a id="6619" href="VecMat.html#6569" class="Bound">S</a> <a id="6621" href="Relation.Binary.Core.html#1757" class="Function Operator">⟶</a> <a id="6623" href="VecMat.html#6583" class="Bound">T</a> <a id="6625" class="Symbol">→</a> <a id="6627" class="Symbol">∀</a> <a id="6629" class="Symbol">{</a><a id="6630" href="VecMat.html#6630" class="Bound">n</a> <a id="6632" href="VecMat.html#6632" class="Bound">xs</a> <a id="6635" href="VecMat.html#6635" class="Bound">xs′</a> <a id="6639" href="VecMat.html#6639" class="Bound">ys</a> <a id="6642" href="VecMat.html#6642" class="Bound">ys′</a><a id="6645" class="Symbol">}</a> <a id="6647" class="Symbol">→</a>
    <a id="6653" href="VecMat.html#3735" class="Datatype">Pw</a> <a id="6656" href="VecMat.html#6555" class="Bound">R</a> <a id="6658" class="Symbol">{</a><a id="6659" class="Argument">n</a> <a id="6661" class="Symbol">=</a> <a id="6663" href="VecMat.html#6630" class="Bound">n</a><a id="6664" class="Symbol">}</a> <a id="6666" href="VecMat.html#6632" class="Bound">xs</a> <a id="6669" href="VecMat.html#6635" class="Bound">xs′</a> <a id="6673" class="Symbol">→</a> <a id="6675" href="VecMat.html#3735" class="Datatype">Pw</a> <a id="6678" href="VecMat.html#6569" class="Bound">S</a> <a id="6680" href="VecMat.html#6639" class="Bound">ys</a> <a id="6683" href="VecMat.html#6642" class="Bound">ys′</a> <a id="6687" class="Symbol">→</a> <a id="6689" href="VecMat.html#3735" class="Datatype">Pw</a> <a id="6692" href="VecMat.html#6583" class="Bound">T</a> <a id="6694" class="Symbol">(</a><a id="6695" href="VecMat.html#5183" class="Function">zip</a> <a id="6699" href="VecMat.html#6539" class="Bound">f</a> <a id="6701" href="VecMat.html#6632" class="Bound">xs</a> <a id="6704" href="VecMat.html#6639" class="Bound">ys</a><a id="6706" class="Symbol">)</a> <a id="6708" class="Symbol">(</a><a id="6709" href="VecMat.html#5183" class="Function">zip</a> <a id="6713" href="VecMat.html#6539" class="Bound">f</a> <a id="6715" href="VecMat.html#6635" class="Bound">xs′</a> <a id="6719" href="VecMat.html#6642" class="Bound">ys′</a><a id="6722" class="Symbol">)</a>
  <a id="6726" href="VecMat.html#6515" class="Function">Pw-zip</a> <a id="6733" href="VecMat.html#6733" class="Bound">p</a> <a id="6735" href="VecMat.html#3792" class="InductiveConstructor">[]</a> <a id="6738" href="VecMat.html#3792" class="InductiveConstructor">[]</a> <a id="6741" class="Symbol">=</a> <a id="6743" href="VecMat.html#3792" class="InductiveConstructor">[]</a>
  <a id="6748" href="VecMat.html#6515" class="Function">Pw-zip</a> <a id="6755" href="VecMat.html#6755" class="Bound">p</a> <a id="6757" class="Symbol">(</a><a id="6758" href="VecMat.html#6758" class="Bound">r</a> <a id="6760" href="VecMat.html#3812" class="InductiveConstructor Operator">∷</a> <a id="6762" href="VecMat.html#6762" class="Bound">rs</a><a id="6764" class="Symbol">)</a> <a id="6766" class="Symbol">(</a><a id="6767" href="VecMat.html#6767" class="Bound">s</a> <a id="6769" href="VecMat.html#3812" class="InductiveConstructor Operator">∷</a> <a id="6771" href="VecMat.html#6771" class="Bound">ss</a><a id="6773" class="Symbol">)</a> <a id="6775" class="Symbol">=</a> <a id="6777" href="VecMat.html#6755" class="Bound">p</a> <a id="6779" href="VecMat.html#6758" class="Bound">r</a> <a id="6781" href="VecMat.html#6767" class="Bound">s</a> <a id="6783" href="VecMat.html#3812" class="InductiveConstructor Operator">∷</a> <a id="6785" href="VecMat.html#6515" class="Function">Pw-zip</a> <a id="6792" href="VecMat.html#6755" class="Bound">p</a> <a id="6794" href="VecMat.html#6762" class="Bound">rs</a> <a id="6797" href="VecMat.html#6771" class="Bound">ss</a>

  <a id="Naïve.Pw-outer"></a><a id="6803" href="VecMat.html#6803" class="Function">Pw-outer</a> <a id="6812" class="Symbol">:</a>
    <a id="6818" class="Symbol">∀</a> <a id="6820" class="Symbol">{</a><a id="6821" href="VecMat.html#6821" class="Bound">r</a> <a id="6823" href="VecMat.html#6823" class="Bound">s</a> <a id="6825" href="VecMat.html#6825" class="Bound">t</a><a id="6826" class="Symbol">}</a> <a id="6828" class="Symbol">{</a><a id="6829" href="VecMat.html#6829" class="Bound">f</a> <a id="6831" class="Symbol">:</a> <a id="6833" href="VecMat.html#2651" class="Generalizable">A</a> <a id="6835" class="Symbol">→</a> <a id="6837" href="VecMat.html#2663" class="Generalizable">B</a> <a id="6839" class="Symbol">→</a> <a id="6841" href="VecMat.html#2675" class="Generalizable">C</a><a id="6842" class="Symbol">}</a> <a id="6844" class="Symbol">{</a><a id="6845" href="VecMat.html#6845" class="Bound">R</a> <a id="6847" class="Symbol">:</a> <a id="6849" href="Relation.Binary.Core.html#1071" class="Function">Rel</a> <a id="6853" href="VecMat.html#2651" class="Generalizable">A</a> <a id="6855" href="VecMat.html#6821" class="Bound">r</a><a id="6856" class="Symbol">}</a> <a id="6858" class="Symbol">{</a><a id="6859" href="VecMat.html#6859" class="Bound">S</a> <a id="6861" class="Symbol">:</a> <a id="6863" href="Relation.Binary.Core.html#1071" class="Function">Rel</a> <a id="6867" href="VecMat.html#2663" class="Generalizable">B</a> <a id="6869" href="VecMat.html#6823" class="Bound">s</a><a id="6870" class="Symbol">}</a> <a id="6872" class="Symbol">{</a><a id="6873" href="VecMat.html#6873" class="Bound">T</a> <a id="6875" class="Symbol">:</a> <a id="6877" href="Relation.Binary.Core.html#1071" class="Function">Rel</a> <a id="6881" href="VecMat.html#2675" class="Generalizable">C</a> <a id="6883" href="VecMat.html#6825" class="Bound">t</a><a id="6884" class="Symbol">}</a> <a id="6886" class="Symbol">→</a>
    <a id="6892" href="VecMat.html#6829" class="Bound">f</a> <a id="6894" href="Relation.Binary.Core.html#1757" class="Function Operator">Preserves₂</a> <a id="6905" href="VecMat.html#6845" class="Bound">R</a> <a id="6907" href="Relation.Binary.Core.html#1757" class="Function Operator">⟶</a> <a id="6909" href="VecMat.html#6859" class="Bound">S</a> <a id="6911" href="Relation.Binary.Core.html#1757" class="Function Operator">⟶</a> <a id="6913" href="VecMat.html#6873" class="Bound">T</a> <a id="6915" class="Symbol">→</a> <a id="6917" class="Symbol">∀</a> <a id="6919" class="Symbol">{</a><a id="6920" href="VecMat.html#6920" class="Bound">m</a> <a id="6922" href="VecMat.html#6922" class="Bound">n</a> <a id="6924" href="VecMat.html#6924" class="Bound">xs</a> <a id="6927" href="VecMat.html#6927" class="Bound">xs′</a> <a id="6931" href="VecMat.html#6931" class="Bound">ys</a> <a id="6934" href="VecMat.html#6934" class="Bound">ys′</a><a id="6937" class="Symbol">}</a> <a id="6939" class="Symbol">→</a>
    <a id="6945" href="VecMat.html#3735" class="Datatype">Pw</a> <a id="6948" href="VecMat.html#6845" class="Bound">R</a> <a id="6950" class="Symbol">{</a><a id="6951" class="Argument">n</a> <a id="6953" class="Symbol">=</a> <a id="6955" href="VecMat.html#6920" class="Bound">m</a><a id="6956" class="Symbol">}</a> <a id="6958" href="VecMat.html#6924" class="Bound">xs</a> <a id="6961" href="VecMat.html#6927" class="Bound">xs′</a> <a id="6965" class="Symbol">→</a> <a id="6967" href="VecMat.html#3735" class="Datatype">Pw</a> <a id="6970" href="VecMat.html#6859" class="Bound">S</a> <a id="6972" class="Symbol">{</a><a id="6973" class="Argument">n</a> <a id="6975" class="Symbol">=</a> <a id="6977" href="VecMat.html#6922" class="Bound">n</a><a id="6978" class="Symbol">}</a> <a id="6980" href="VecMat.html#6931" class="Bound">ys</a> <a id="6983" href="VecMat.html#6934" class="Bound">ys′</a> <a id="6987" class="Symbol">→</a>
    <a id="6993" href="VecMat.html#3735" class="Datatype">Pw</a> <a id="6996" class="Symbol">(</a><a id="6997" href="VecMat.html#3735" class="Datatype">Pw</a> <a id="7000" href="VecMat.html#6873" class="Bound">T</a><a id="7001" class="Symbol">)</a> <a id="7003" class="Symbol">(</a><a id="7004" href="VecMat.html#5319" class="Function">outer</a> <a id="7010" href="VecMat.html#6829" class="Bound">f</a> <a id="7012" href="VecMat.html#6924" class="Bound">xs</a> <a id="7015" href="VecMat.html#6931" class="Bound">ys</a><a id="7017" class="Symbol">)</a> <a id="7019" class="Symbol">(</a><a id="7020" href="VecMat.html#5319" class="Function">outer</a> <a id="7026" href="VecMat.html#6829" class="Bound">f</a> <a id="7028" href="VecMat.html#6927" class="Bound">xs′</a> <a id="7032" href="VecMat.html#6934" class="Bound">ys′</a><a id="7035" class="Symbol">)</a>
  <a id="7039" href="VecMat.html#6803" class="Function">Pw-outer</a> <a id="7048" href="VecMat.html#7048" class="Bound">p</a> <a id="7050" href="VecMat.html#3792" class="InductiveConstructor">[]</a> <a id="7053" href="VecMat.html#7053" class="Bound">ss</a> <a id="7056" class="Symbol">=</a> <a id="7058" href="VecMat.html#3792" class="InductiveConstructor">[]</a>
  <a id="7063" href="VecMat.html#6803" class="Function">Pw-outer</a> <a id="7072" href="VecMat.html#7072" class="Bound">p</a> <a id="7074" class="Symbol">(</a><a id="7075" href="VecMat.html#7075" class="Bound">r</a> <a id="7077" href="VecMat.html#3812" class="InductiveConstructor Operator">∷</a> <a id="7079" href="VecMat.html#7079" class="Bound">rs</a><a id="7081" class="Symbol">)</a> <a id="7083" href="VecMat.html#7083" class="Bound">ss</a> <a id="7086" class="Symbol">=</a> <a id="7088" href="VecMat.html#5838" class="Function">Pw-map</a> <a id="7095" class="Symbol">(</a><a id="7096" href="VecMat.html#7072" class="Bound">p</a> <a id="7098" href="VecMat.html#7075" class="Bound">r</a><a id="7099" class="Symbol">)</a> <a id="7101" href="VecMat.html#7083" class="Bound">ss</a> <a id="7104" href="VecMat.html#3812" class="InductiveConstructor Operator">∷</a> <a id="7106" href="VecMat.html#6803" class="Function">Pw-outer</a> <a id="7115" href="VecMat.html#7072" class="Bound">p</a> <a id="7117" href="VecMat.html#7079" class="Bound">rs</a> <a id="7120" href="VecMat.html#7083" class="Bound">ss</a>

  <a id="Naïve.≡⇒Pw-≡"></a><a id="7126" href="VecMat.html#7126" class="Function">≡⇒Pw-≡</a> <a id="7133" class="Symbol">:</a> <a id="7135" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">_≡_</a> <a id="7139" href="Relation.Binary.Core.html#1383" class="Function Operator">⇒</a> <a id="7141" href="VecMat.html#3735" class="Datatype">Pw</a> <a id="7144" class="Symbol">(</a><a id="7145" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">_≡_</a> <a id="7149" class="Symbol">{</a><a id="7150" class="Argument">A</a> <a id="7152" class="Symbol">=</a> <a id="7154" href="VecMat.html#2651" class="Generalizable">A</a><a id="7155" class="Symbol">})</a> <a id="7158" class="Symbol">{</a><a id="7159" class="Argument">n</a> <a id="7161" class="Symbol">=</a> <a id="7163" href="VecMat.html#2731" class="Generalizable">n</a><a id="7164" class="Symbol">}</a>
  <a id="7168" href="VecMat.html#7126" class="Function">≡⇒Pw-≡</a> <a id="7175" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">≡.refl</a> <a id="7182" class="Symbol">=</a> <a id="7184" href="VecMat.html#7201" class="Function">go</a>
    <a id="7191" class="Keyword">where</a>
    <a id="7201" href="VecMat.html#7201" class="Function">go</a> <a id="7204" class="Symbol">:</a> <a id="7206" class="Symbol">∀</a> <a id="7208" class="Symbol">{</a><a id="7209" href="VecMat.html#7209" class="Bound">xs</a><a id="7211" class="Symbol">}</a> <a id="7213" class="Symbol">→</a> <a id="7215" href="VecMat.html#3735" class="Datatype">Pw</a> <a id="7218" class="Symbol">(</a><a id="7219" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">_≡_</a> <a id="7223" class="Symbol">{</a><a id="7224" class="Argument">A</a> <a id="7226" class="Symbol">=</a> <a id="7228" href="VecMat.html#2651" class="Generalizable">A</a><a id="7229" class="Symbol">})</a> <a id="7232" class="Symbol">{</a><a id="7233" class="Argument">n</a> <a id="7235" class="Symbol">=</a> <a id="7237" href="VecMat.html#2731" class="Generalizable">n</a><a id="7238" class="Symbol">}</a> <a id="7240" href="VecMat.html#7209" class="Bound">xs</a> <a id="7243" href="VecMat.html#7209" class="Bound">xs</a>
    <a id="7250" href="VecMat.html#7201" class="Function">go</a> <a id="7253" class="Symbol">{</a><a id="7254" class="Argument">xs</a> <a id="7257" class="Symbol">=</a> <a id="7259" href="VecMat.html#3098" class="InductiveConstructor">[]</a><a id="7261" class="Symbol">}</a> <a id="7263" class="Symbol">=</a> <a id="7265" href="VecMat.html#3792" class="InductiveConstructor">[]</a>
    <a id="7272" href="VecMat.html#7201" class="Function">go</a> <a id="7275" class="Symbol">{</a><a id="7276" class="Argument">xs</a> <a id="7279" class="Symbol">=</a> <a id="7281" href="VecMat.html#7281" class="Bound">x</a> <a id="7283" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="7285" href="VecMat.html#7285" class="Bound">xs</a><a id="7287" class="Symbol">}</a> <a id="7289" class="Symbol">=</a> <a id="7291" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">≡.refl</a> <a id="7298" href="VecMat.html#3812" class="InductiveConstructor Operator">∷</a> <a id="7300" href="VecMat.html#7201" class="Function">go</a>
</pre>-->
<p>Accessing rows of matrices is easy, because we can view the first row by pattern matching. However, columns are buried, and to access them we need a function defined by induction on the rows.</p>
<pre class="Agda">  <a id="Naïve.left/rest"></a><a id="7515" href="VecMat.html#7515" class="Function">left/rest</a> <a id="7525" class="Symbol">:</a> <a id="7527" href="VecMat.html#3487" class="Function">Mat</a> <a id="7531" href="VecMat.html#2651" class="Generalizable">A</a> <a id="7533" href="VecMat.html#2729" class="Generalizable">m</a> <a id="7535" class="Symbol">(</a><a id="7536" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="7540" href="VecMat.html#2731" class="Generalizable">n</a><a id="7541" class="Symbol">)</a> <a id="7543" class="Symbol">→</a> <a id="7545" href="VecMat.html#3054" class="Datatype">Vec</a> <a id="7549" href="VecMat.html#2651" class="Generalizable">A</a> <a id="7551" href="VecMat.html#2729" class="Generalizable">m</a> <a id="7553" href="Data.Product.html#1162" class="Function Operator">×</a> <a id="7555" href="VecMat.html#3487" class="Function">Mat</a> <a id="7559" href="VecMat.html#2651" class="Generalizable">A</a> <a id="7561" href="VecMat.html#2729" class="Generalizable">m</a> <a id="7563" href="VecMat.html#2731" class="Generalizable">n</a>
  <a id="7567" href="VecMat.html#7515" class="Function">left/rest</a> <a id="7577" href="VecMat.html#3098" class="InductiveConstructor">[]</a> <a id="7580" class="Symbol">=</a> <a id="7582" href="VecMat.html#3098" class="InductiveConstructor">[]</a> <a id="7585" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="7587" href="VecMat.html#3098" class="InductiveConstructor">[]</a>
  <a id="7592" href="VecMat.html#7515" class="Function">left/rest</a> <a id="7602" class="Symbol">((</a><a id="7604" href="VecMat.html#7604" class="Bound">x</a> <a id="7606" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="7608" href="VecMat.html#7608" class="Bound">v</a><a id="7609" class="Symbol">)</a> <a id="7611" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="7613" href="VecMat.html#7613" class="Bound">M</a><a id="7614" class="Symbol">)</a> <a id="7616" class="Symbol">=</a> <a id="7618" href="Data.Product.html#2430" class="Function">Σ.map</a> <a id="7624" class="Symbol">(</a><a id="7625" href="VecMat.html#7604" class="Bound">x</a> <a id="7627" href="VecMat.html#3118" class="InductiveConstructor Operator">∷_</a><a id="7629" class="Symbol">)</a> <a id="7631" class="Symbol">(</a><a id="7632" href="VecMat.html#7608" class="Bound">v</a> <a id="7634" href="VecMat.html#3118" class="InductiveConstructor Operator">∷_</a><a id="7636" class="Symbol">)</a> <a id="7638" class="Symbol">(</a><a id="7639" href="VecMat.html#7515" class="Function">left/rest</a> <a id="7649" href="VecMat.html#7613" class="Bound">M</a><a id="7650" class="Symbol">)</a>
</pre>
<p><code>lest/rest-map-∷</code> is a lemma we will need later. It says that adding a constant column and then viewing a column gives back that constant column and the original matrix.</p>
<pre class="Agda">  <a id="Naïve.left/rest-map-∷"></a><a id="7838" href="VecMat.html#7838" class="Function">left/rest-map-∷</a> <a id="7854" class="Symbol">:</a> <a id="7856" class="Symbol">(</a><a id="7857" href="VecMat.html#7857" class="Bound">x</a> <a id="7859" class="Symbol">:</a> <a id="7861" href="VecMat.html#2651" class="Generalizable">A</a><a id="7862" class="Symbol">)</a> <a id="7864" class="Symbol">(</a><a id="7865" href="VecMat.html#7865" class="Bound">M</a> <a id="7867" class="Symbol">:</a> <a id="7869" href="VecMat.html#3487" class="Function">Mat</a> <a id="7873" href="VecMat.html#2651" class="Generalizable">A</a> <a id="7875" href="VecMat.html#2729" class="Generalizable">m</a> <a id="7877" href="VecMat.html#2731" class="Generalizable">n</a><a id="7878" class="Symbol">)</a> <a id="7880" class="Symbol">→</a>
                    <a id="7902" href="VecMat.html#7515" class="Function">left/rest</a> <a id="7912" class="Symbol">(</a><a id="7913" href="VecMat.html#4899" class="Function">map</a> <a id="7917" class="Symbol">(</a><a id="7918" href="VecMat.html#7857" class="Bound">x</a> <a id="7920" href="VecMat.html#3118" class="InductiveConstructor Operator">∷_</a><a id="7922" class="Symbol">)</a> <a id="7924" href="VecMat.html#7865" class="Bound">M</a><a id="7925" class="Symbol">)</a> <a id="7927" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="7929" class="Symbol">(</a><a id="7930" href="VecMat.html#5082" class="Function">replicate</a> <a id="7940" href="VecMat.html#7857" class="Bound">x</a> <a id="7942" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="7944" href="VecMat.html#7865" class="Bound">M</a><a id="7945" class="Symbol">)</a>
  <a id="7949" href="VecMat.html#7838" class="Function">left/rest-map-∷</a> <a id="7965" href="VecMat.html#7965" class="Bound">x</a> <a id="7967" href="VecMat.html#3098" class="InductiveConstructor">[]</a> <a id="7970" class="Symbol">=</a> <a id="7972" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">≡.refl</a>
  <a id="7981" href="VecMat.html#7838" class="Function">left/rest-map-∷</a> <a id="7997" href="VecMat.html#7997" class="Bound">x</a> <a id="7999" class="Symbol">(</a><a id="8000" href="VecMat.html#8000" class="Bound">u</a> <a id="8002" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="8004" href="VecMat.html#8004" class="Bound">M</a><a id="8005" class="Symbol">)</a> <a id="8007" class="Keyword">rewrite</a> <a id="8015" href="VecMat.html#7838" class="Function">left/rest-map-∷</a> <a id="8031" href="VecMat.html#7997" class="Bound">x</a> <a id="8033" href="VecMat.html#8004" class="Bound">M</a> <a id="8035" class="Symbol">=</a> <a id="8037" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">≡.refl</a>
</pre>
<p>With these done, we can focus on vector/matrix operations. Vectors have a zero, addition, and scaling by a coefficient.</p>
<pre class="Agda">  <a id="8180" class="Keyword">module</a> <a id="WithSemiring"></a><a id="8187" href="VecMat.html#8187" class="Module">WithSemiring</a> <a id="8200" class="Symbol">(</a><a id="8201" href="VecMat.html#8201" class="Bound">R</a> <a id="8203" class="Symbol">:</a> <a id="8205" href="Algebra.html#12064" class="Record">Semiring</a> <a id="8214" href="VecMat.html#2634" class="Generalizable">c</a> <a id="8216" href="VecMat.html#2639" class="Generalizable">ℓ</a><a id="8217" class="Symbol">)</a> <a id="8219" class="Keyword">where</a>
    <a id="8229" class="Keyword">open</a> <a id="8234" href="Algebra.html#12064" class="Module">Semiring</a> <a id="8243" href="VecMat.html#8201" class="Bound">R</a>

    <a id="8250" class="Keyword">infixr</a> <a id="8257" class="Number">7</a> <a id="8259" href="VecMat.html#8417" class="Function Operator">_*ᵥ_</a> <a id="8264" href="VecMat.html#8883" class="Function Operator">_*ₘ_</a> <a id="8269" href="VecMat.html#8802" class="Function Operator">_⊗ₒ_</a>
    <a id="8278" class="Keyword">infixr</a> <a id="8285" class="Number">6</a> <a id="8287" href="VecMat.html#8348" class="Function Operator">_+ᵥ_</a> <a id="8292" href="VecMat.html#8619" class="Function Operator">_+ₘ_</a>

    <a id="Naïve.WithSemiring.0ᵥ"></a><a id="8302" href="VecMat.html#8302" class="Function">0ᵥ</a> <a id="8305" class="Symbol">:</a> <a id="8307" href="VecMat.html#3054" class="Datatype">Vec</a> <a id="8311" href="Algebra.html#12160" class="Field">Carrier</a> <a id="8319" href="VecMat.html#2729" class="Generalizable">m</a>
    <a id="8325" href="VecMat.html#8302" class="Function">0ᵥ</a> <a id="8328" class="Symbol">=</a> <a id="8330" href="VecMat.html#5082" class="Function">replicate</a> <a id="8340" href="Algebra.html#12272" class="Field">0#</a>

    <a id="Naïve.WithSemiring._+ᵥ_"></a><a id="8348" href="VecMat.html#8348" class="Function Operator">_+ᵥ_</a> <a id="8353" class="Symbol">:</a> <a id="8355" class="Symbol">(</a><a id="8356" href="VecMat.html#8356" class="Bound">u</a> <a id="8358" href="VecMat.html#8358" class="Bound">v</a> <a id="8360" class="Symbol">:</a> <a id="8362" href="VecMat.html#3054" class="Datatype">Vec</a> <a id="8366" href="Algebra.html#12160" class="Field">Carrier</a> <a id="8374" href="VecMat.html#2729" class="Generalizable">m</a><a id="8375" class="Symbol">)</a> <a id="8377" class="Symbol">→</a> <a id="8379" href="VecMat.html#3054" class="Datatype">Vec</a> <a id="8383" href="Algebra.html#12160" class="Field">Carrier</a> <a id="8391" href="VecMat.html#2729" class="Generalizable">m</a>
    <a id="8397" href="VecMat.html#8348" class="Function Operator">_+ᵥ_</a> <a id="8402" class="Symbol">=</a> <a id="8404" href="VecMat.html#5183" class="Function">zip</a> <a id="8408" href="Algebra.html#12214" class="Field Operator">_+_</a>

    <a id="Naïve.WithSemiring._*ᵥ_"></a><a id="8417" href="VecMat.html#8417" class="Function Operator">_*ᵥ_</a> <a id="8422" class="Symbol">:</a> <a id="8424" href="Algebra.html#12160" class="Field">Carrier</a> <a id="8432" class="Symbol">→</a> <a id="8434" href="VecMat.html#3054" class="Datatype">Vec</a> <a id="8438" href="Algebra.html#12160" class="Field">Carrier</a> <a id="8446" href="VecMat.html#2729" class="Generalizable">m</a> <a id="8448" class="Symbol">→</a> <a id="8450" href="VecMat.html#3054" class="Datatype">Vec</a> <a id="8454" href="Algebra.html#12160" class="Field">Carrier</a> <a id="8462" href="VecMat.html#2729" class="Generalizable">m</a>
    <a id="8468" href="VecMat.html#8468" class="Bound">x</a> <a id="8470" href="VecMat.html#8417" class="Function Operator">*ᵥ</a> <a id="8473" href="VecMat.html#8473" class="Bound">u</a> <a id="8475" class="Symbol">=</a> <a id="8477" href="VecMat.html#4899" class="Function">map</a> <a id="8481" class="Symbol">(</a><a id="8482" href="VecMat.html#8468" class="Bound">x</a> <a id="8484" href="Algebra.html#12243" class="Field Operator">*_</a><a id="8486" class="Symbol">)</a> <a id="8488" href="VecMat.html#8473" class="Bound">u</a>
</pre>
<p>These definitions are convenient for use in matrix operations.</p>
<pre class="Agda">    <a id="Naïve.WithSemiring.0ₘ"></a><a id="8571" href="VecMat.html#8571" class="Function">0ₘ</a> <a id="8574" class="Symbol">:</a> <a id="8576" href="VecMat.html#3487" class="Function">Mat</a> <a id="8580" href="Algebra.html#12160" class="Field">Carrier</a> <a id="8588" href="VecMat.html#2729" class="Generalizable">m</a> <a id="8590" href="VecMat.html#2731" class="Generalizable">n</a>
    <a id="8596" href="VecMat.html#8571" class="Function">0ₘ</a> <a id="8599" class="Symbol">=</a> <a id="8601" href="VecMat.html#5082" class="Function">replicate</a> <a id="8611" href="VecMat.html#8302" class="Function">0ᵥ</a>

    <a id="Naïve.WithSemiring._+ₘ_"></a><a id="8619" href="VecMat.html#8619" class="Function Operator">_+ₘ_</a> <a id="8624" class="Symbol">:</a> <a id="8626" class="Symbol">(</a><a id="8627" href="VecMat.html#8627" class="Bound">M</a> <a id="8629" href="VecMat.html#8629" class="Bound">N</a> <a id="8631" class="Symbol">:</a> <a id="8633" href="VecMat.html#3487" class="Function">Mat</a> <a id="8637" href="Algebra.html#12160" class="Field">Carrier</a> <a id="8645" href="VecMat.html#2729" class="Generalizable">m</a> <a id="8647" href="VecMat.html#2731" class="Generalizable">n</a><a id="8648" class="Symbol">)</a> <a id="8650" class="Symbol">→</a> <a id="8652" href="VecMat.html#3487" class="Function">Mat</a> <a id="8656" href="Algebra.html#12160" class="Field">Carrier</a> <a id="8664" href="VecMat.html#2729" class="Generalizable">m</a> <a id="8666" href="VecMat.html#2731" class="Generalizable">n</a>
    <a id="8672" href="VecMat.html#8619" class="Function Operator">_+ₘ_</a> <a id="8677" class="Symbol">=</a> <a id="8679" href="VecMat.html#5183" class="Function">zip</a> <a id="8683" href="VecMat.html#8348" class="Function Operator">_+ᵥ_</a>

    <a id="Naïve.WithSemiring.1ₘ"></a><a id="8693" href="VecMat.html#8693" class="Function">1ₘ</a> <a id="8696" class="Symbol">:</a> <a id="8698" href="VecMat.html#3487" class="Function">Mat</a> <a id="8702" href="Algebra.html#12160" class="Field">Carrier</a> <a id="8710" href="VecMat.html#2729" class="Generalizable">m</a> <a id="8712" href="VecMat.html#2729" class="Generalizable">m</a>
    <a id="8718" href="VecMat.html#8693" class="Function">1ₘ</a> <a id="8721" class="Symbol">{</a><a id="8722" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a><a id="8726" class="Symbol">}</a> <a id="8728" class="Symbol">=</a> <a id="8730" href="VecMat.html#3098" class="InductiveConstructor">[]</a>
    <a id="8737" href="VecMat.html#8693" class="Function">1ₘ</a> <a id="8740" class="Symbol">{</a><a id="8741" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="8745" href="VecMat.html#8745" class="Bound">m</a><a id="8746" class="Symbol">}</a> <a id="8748" class="Symbol">=</a> <a id="8750" class="Symbol">(</a><a id="8751" href="Algebra.html#12297" class="Field">1#</a> <a id="8754" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a>    <a id="8759" href="VecMat.html#8302" class="Function">0ᵥ</a><a id="8761" class="Symbol">)</a>
           <a id="8774" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="8776" href="VecMat.html#4899" class="Function">map</a> <a id="8780" class="Symbol">(</a><a id="8781" href="Algebra.html#12272" class="Field">0#</a> <a id="8784" href="VecMat.html#3118" class="InductiveConstructor Operator">∷_</a><a id="8786" class="Symbol">)</a> <a id="8788" class="Symbol">(</a><a id="8789" href="VecMat.html#8693" class="Function">1ₘ</a> <a id="8792" class="Symbol">{</a><a id="8793" href="VecMat.html#8745" class="Bound">m</a><a id="8794" class="Symbol">})</a>

    <a id="Naïve.WithSemiring._⊗ₒ_"></a><a id="8802" href="VecMat.html#8802" class="Function Operator">_⊗ₒ_</a> <a id="8807" class="Symbol">:</a> <a id="8809" href="VecMat.html#3054" class="Datatype">Vec</a> <a id="8813" href="Algebra.html#12160" class="Field">Carrier</a> <a id="8821" href="VecMat.html#2729" class="Generalizable">m</a> <a id="8823" class="Symbol">→</a> <a id="8825" href="VecMat.html#3054" class="Datatype">Vec</a> <a id="8829" href="Algebra.html#12160" class="Field">Carrier</a> <a id="8837" href="VecMat.html#2731" class="Generalizable">n</a> <a id="8839" class="Symbol">→</a> <a id="8841" href="VecMat.html#3487" class="Function">Mat</a> <a id="8845" href="Algebra.html#12160" class="Field">Carrier</a> <a id="8853" href="VecMat.html#2729" class="Generalizable">m</a> <a id="8855" href="VecMat.html#2731" class="Generalizable">n</a>
    <a id="8861" href="VecMat.html#8802" class="Function Operator">_⊗ₒ_</a> <a id="8866" class="Symbol">=</a> <a id="8868" href="VecMat.html#5319" class="Function">outer</a> <a id="8874" href="Algebra.html#12243" class="Field Operator">_*_</a>

    <a id="Naïve.WithSemiring._*ₘ_"></a><a id="8883" href="VecMat.html#8883" class="Function Operator">_*ₘ_</a> <a id="8888" class="Symbol">:</a> <a id="8890" href="VecMat.html#3487" class="Function">Mat</a> <a id="8894" href="Algebra.html#12160" class="Field">Carrier</a> <a id="8902" href="VecMat.html#2729" class="Generalizable">m</a> <a id="8904" href="VecMat.html#2731" class="Generalizable">n</a> <a id="8906" class="Symbol">→</a> <a id="8908" href="VecMat.html#3487" class="Function">Mat</a> <a id="8912" href="Algebra.html#12160" class="Field">Carrier</a> <a id="8920" href="VecMat.html#2731" class="Generalizable">n</a> <a id="8922" href="VecMat.html#2733" class="Generalizable">o</a> <a id="8924" class="Symbol">→</a> <a id="8926" href="VecMat.html#3487" class="Function">Mat</a> <a id="8930" href="Algebra.html#12160" class="Field">Carrier</a> <a id="8938" href="VecMat.html#2729" class="Generalizable">m</a> <a id="8940" href="VecMat.html#2733" class="Generalizable">o</a>
    <a id="8946" class="Symbol">_</a> <a id="8948" href="VecMat.html#8883" class="Function Operator">*ₘ</a> <a id="8951" href="VecMat.html#3098" class="InductiveConstructor">[]</a> <a id="8954" class="Symbol">=</a> <a id="8956" href="VecMat.html#8571" class="Function">0ₘ</a>
    <a id="8963" href="VecMat.html#8963" class="Bound">uM</a> <a id="8966" href="VecMat.html#8883" class="Function Operator">*ₘ</a> <a id="8969" class="Symbol">(</a><a id="8970" href="VecMat.html#8970" class="Bound">v</a> <a id="8972" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="8974" href="VecMat.html#8974" class="Bound">N</a><a id="8975" class="Symbol">)</a> <a id="8977" class="Symbol">=</a>
      <a id="8985" class="Keyword">let</a> <a id="8989" href="VecMat.html#8989" class="Bound">u</a> <a id="8991" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="8993" href="VecMat.html#8993" class="Bound">M</a> <a id="8995" class="Symbol">=</a> <a id="8997" href="VecMat.html#7515" class="Function">left/rest</a> <a id="9007" href="VecMat.html#8963" class="Bound">uM</a> <a id="9010" class="Keyword">in</a>
      <a id="9019" href="VecMat.html#8989" class="Bound">u</a> <a id="9021" href="VecMat.html#8802" class="Function Operator">⊗ₒ</a> <a id="9024" href="VecMat.html#8970" class="Bound">v</a> <a id="9026" href="VecMat.html#8619" class="Function Operator">+ₘ</a> <a id="9029" href="VecMat.html#8993" class="Bound">M</a> <a id="9031" href="VecMat.html#8883" class="Function Operator">*ₘ</a> <a id="9034" href="VecMat.html#8974" class="Bound">N</a>
</pre>
<p>This implementation of <code>_*ₘ_</code> is by no means canonical. However, I argue that it fits the spirit of inductive vectors well. In particular, this definition is primarily by induction on <code>N</code>, one of the inputs. I have tried several other implementations in the past, but none were particularly nice.</p>
<p>In the Agda standard library, algebraic structures each come with an equivalence relation <code>_≈_</code>, which is weaker than propositional equality. Algebraic laws only hold up to <code>_≈_</code>, so we will need to have similar equivalence relations for vectors and matrices.</p>
<pre class="Agda">    <a id="9612" class="Keyword">infix</a> <a id="9618" class="Number">4</a> <a id="9620" href="VecMat.html#9635" class="Function Operator">_≈ᵥ_</a> <a id="9625" href="VecMat.html#9695" class="Function Operator">_≈ₘ_</a>

    <a id="Naïve.WithSemiring._≈ᵥ_"></a><a id="9635" href="VecMat.html#9635" class="Function Operator">_≈ᵥ_</a> <a id="9640" class="Symbol">:</a> <a id="9642" class="Symbol">(</a><a id="9643" href="VecMat.html#9643" class="Bound">u</a> <a id="9645" href="VecMat.html#9645" class="Bound">v</a> <a id="9647" class="Symbol">:</a> <a id="9649" href="VecMat.html#3054" class="Datatype">Vec</a> <a id="9653" href="Algebra.html#12160" class="Field">Carrier</a> <a id="9661" href="VecMat.html#2731" class="Generalizable">n</a><a id="9662" class="Symbol">)</a> <a id="9664" class="Symbol">→</a> <a id="9666" class="PrimitiveType">Set</a> <a id="9670" href="VecMat.html#8216" class="Bound">ℓ</a>
    <a id="9676" href="VecMat.html#9635" class="Function Operator">_≈ᵥ_</a> <a id="9681" class="Symbol">=</a> <a id="9683" href="VecMat.html#3735" class="Datatype">Pw</a> <a id="9686" href="Algebra.html#12183" class="Field Operator">_≈_</a>

    <a id="Naïve.WithSemiring._≈ₘ_"></a><a id="9695" href="VecMat.html#9695" class="Function Operator">_≈ₘ_</a> <a id="9700" class="Symbol">:</a> <a id="9702" class="Symbol">(</a><a id="9703" href="VecMat.html#9703" class="Bound">M</a> <a id="9705" href="VecMat.html#9705" class="Bound">N</a> <a id="9707" class="Symbol">:</a> <a id="9709" href="VecMat.html#3487" class="Function">Mat</a> <a id="9713" href="Algebra.html#12160" class="Field">Carrier</a> <a id="9721" href="VecMat.html#2729" class="Generalizable">m</a> <a id="9723" href="VecMat.html#2731" class="Generalizable">n</a><a id="9724" class="Symbol">)</a> <a id="9726" class="Symbol">→</a> <a id="9728" class="PrimitiveType">Set</a> <a id="9732" href="VecMat.html#8216" class="Bound">ℓ</a>
    <a id="9738" href="VecMat.html#9695" class="Function Operator">_≈ₘ_</a> <a id="9743" class="Symbol">=</a> <a id="9745" href="VecMat.html#3735" class="Datatype">Pw</a> <a id="9748" href="VecMat.html#9635" class="Function Operator">_≈ᵥ_</a>
</pre>
<!--
<pre class="Agda">    <a id="Naïve.WithSemiring.reflᵥ"></a><a id="9775" href="VecMat.html#9775" class="Function">reflᵥ</a> <a id="9781" class="Symbol">:</a> <a id="9783" class="Symbol">{</a><a id="9784" href="VecMat.html#9784" class="Bound">v</a> <a id="9786" class="Symbol">:</a> <a id="9788" href="VecMat.html#3054" class="Datatype">Vec</a> <a id="9792" class="Symbol">_</a> <a id="9794" href="VecMat.html#2729" class="Generalizable">m</a><a id="9795" class="Symbol">}</a> <a id="9797" class="Symbol">→</a> <a id="9799" href="VecMat.html#9784" class="Bound">v</a> <a id="9801" href="VecMat.html#9635" class="Function Operator">≈ᵥ</a> <a id="9804" href="VecMat.html#9784" class="Bound">v</a>
    <a id="9810" href="VecMat.html#9775" class="Function">reflᵥ</a> <a id="9816" class="Symbol">=</a> <a id="9818" href="VecMat.html#3906" class="Function">Pw-refl</a> <a id="9826" href="Relation.Binary.Core.html#7020" class="Function">refl</a>

    <a id="Naïve.WithSemiring.reflₘ"></a><a id="9836" href="VecMat.html#9836" class="Function">reflₘ</a> <a id="9842" class="Symbol">:</a> <a id="9844" class="Symbol">{</a><a id="9845" href="VecMat.html#9845" class="Bound">M</a> <a id="9847" class="Symbol">:</a> <a id="9849" href="VecMat.html#3487" class="Function">Mat</a> <a id="9853" class="Symbol">_</a> <a id="9855" href="VecMat.html#2729" class="Generalizable">m</a> <a id="9857" href="VecMat.html#2731" class="Generalizable">n</a><a id="9858" class="Symbol">}</a> <a id="9860" class="Symbol">→</a> <a id="9862" href="VecMat.html#9845" class="Bound">M</a> <a id="9864" href="VecMat.html#9695" class="Function Operator">≈ₘ</a> <a id="9867" href="VecMat.html#9845" class="Bound">M</a>
    <a id="9873" href="VecMat.html#9836" class="Function">reflₘ</a> <a id="9879" class="Symbol">=</a> <a id="9881" href="VecMat.html#3906" class="Function">Pw-refl</a> <a id="9889" href="VecMat.html#9775" class="Function">reflᵥ</a>

    <a id="Naïve.WithSemiring.transᵥ"></a><a id="9900" href="VecMat.html#9900" class="Function">transᵥ</a> <a id="9907" class="Symbol">:</a> <a id="9909" class="Symbol">{</a><a id="9910" href="VecMat.html#9910" class="Bound">u</a> <a id="9912" href="VecMat.html#9912" class="Bound">v</a> <a id="9914" href="VecMat.html#9914" class="Bound">w</a> <a id="9916" class="Symbol">:</a> <a id="9918" href="VecMat.html#3054" class="Datatype">Vec</a> <a id="9922" class="Symbol">_</a> <a id="9924" href="VecMat.html#2729" class="Generalizable">m</a><a id="9925" class="Symbol">}</a> <a id="9927" class="Symbol">→</a> <a id="9929" href="VecMat.html#9910" class="Bound">u</a> <a id="9931" href="VecMat.html#9635" class="Function Operator">≈ᵥ</a> <a id="9934" href="VecMat.html#9912" class="Bound">v</a> <a id="9936" class="Symbol">→</a> <a id="9938" href="VecMat.html#9912" class="Bound">v</a> <a id="9940" href="VecMat.html#9635" class="Function Operator">≈ᵥ</a> <a id="9943" href="VecMat.html#9914" class="Bound">w</a> <a id="9945" class="Symbol">→</a> <a id="9947" href="VecMat.html#9910" class="Bound">u</a> <a id="9949" href="VecMat.html#9635" class="Function Operator">≈ᵥ</a> <a id="9952" href="VecMat.html#9914" class="Bound">w</a>
    <a id="9958" href="VecMat.html#9900" class="Function">transᵥ</a> <a id="9965" class="Symbol">=</a> <a id="9967" href="VecMat.html#4170" class="Function">Pw-trans</a> <a id="9976" href="Relation.Binary.Core.html#7072" class="Function">trans</a>

    <a id="Naïve.WithSemiring.transₘ"></a><a id="9987" href="VecMat.html#9987" class="Function">transₘ</a> <a id="9994" class="Symbol">:</a> <a id="9996" class="Symbol">{</a><a id="9997" href="VecMat.html#9997" class="Bound">M</a> <a id="9999" href="VecMat.html#9999" class="Bound">N</a> <a id="10001" href="VecMat.html#10001" class="Bound">O</a> <a id="10003" class="Symbol">:</a> <a id="10005" href="VecMat.html#3487" class="Function">Mat</a> <a id="10009" class="Symbol">_</a> <a id="10011" href="VecMat.html#2729" class="Generalizable">m</a> <a id="10013" href="VecMat.html#2731" class="Generalizable">n</a><a id="10014" class="Symbol">}</a> <a id="10016" class="Symbol">→</a> <a id="10018" href="VecMat.html#9997" class="Bound">M</a> <a id="10020" href="VecMat.html#9695" class="Function Operator">≈ₘ</a> <a id="10023" href="VecMat.html#9999" class="Bound">N</a> <a id="10025" class="Symbol">→</a> <a id="10027" href="VecMat.html#9999" class="Bound">N</a> <a id="10029" href="VecMat.html#9695" class="Function Operator">≈ₘ</a> <a id="10032" href="VecMat.html#10001" class="Bound">O</a> <a id="10034" class="Symbol">→</a> <a id="10036" href="VecMat.html#9997" class="Bound">M</a> <a id="10038" href="VecMat.html#9695" class="Function Operator">≈ₘ</a> <a id="10041" href="VecMat.html#10001" class="Bound">O</a>
    <a id="10047" href="VecMat.html#9987" class="Function">transₘ</a> <a id="10054" class="Symbol">=</a> <a id="10056" href="VecMat.html#4170" class="Function">Pw-trans</a> <a id="10065" href="VecMat.html#9900" class="Function">transᵥ</a>

    <a id="Naïve.WithSemiring.+ᵥ-cong"></a><a id="10077" href="VecMat.html#10077" class="Function">+ᵥ-cong</a> <a id="10085" class="Symbol">:</a> <a id="10087" class="Symbol">{</a><a id="10088" href="VecMat.html#10088" class="Bound">u</a> <a id="10090" href="VecMat.html#10090" class="Bound">u′</a> <a id="10093" href="VecMat.html#10093" class="Bound">v</a> <a id="10095" href="VecMat.html#10095" class="Bound">v′</a> <a id="10098" class="Symbol">:</a> <a id="10100" href="VecMat.html#3054" class="Datatype">Vec</a> <a id="10104" class="Symbol">_</a> <a id="10106" href="VecMat.html#2729" class="Generalizable">m</a><a id="10107" class="Symbol">}</a> <a id="10109" class="Symbol">→</a> <a id="10111" href="VecMat.html#10088" class="Bound">u</a> <a id="10113" href="VecMat.html#9635" class="Function Operator">≈ᵥ</a> <a id="10116" href="VecMat.html#10090" class="Bound">u′</a> <a id="10119" class="Symbol">→</a> <a id="10121" href="VecMat.html#10093" class="Bound">v</a> <a id="10123" href="VecMat.html#9635" class="Function Operator">≈ᵥ</a> <a id="10126" href="VecMat.html#10095" class="Bound">v′</a> <a id="10129" class="Symbol">→</a> <a id="10131" href="VecMat.html#10088" class="Bound">u</a> <a id="10133" href="VecMat.html#8348" class="Function Operator">+ᵥ</a> <a id="10136" href="VecMat.html#10093" class="Bound">v</a> <a id="10138" href="VecMat.html#9635" class="Function Operator">≈ᵥ</a> <a id="10141" href="VecMat.html#10090" class="Bound">u′</a> <a id="10144" href="VecMat.html#8348" class="Function Operator">+ᵥ</a> <a id="10147" href="VecMat.html#10095" class="Bound">v′</a>
    <a id="10154" href="VecMat.html#10077" class="Function">+ᵥ-cong</a> <a id="10162" class="Symbol">=</a> <a id="10164" href="VecMat.html#6515" class="Function">Pw-zip</a> <a id="10171" href="Algebra.Structures.html#1078" class="Function">+-cong</a>

    <a id="Naïve.WithSemiring.+ₘ-cong"></a><a id="10183" href="VecMat.html#10183" class="Function">+ₘ-cong</a> <a id="10191" class="Symbol">:</a> <a id="10193" class="Symbol">{</a><a id="10194" href="VecMat.html#10194" class="Bound">M</a> <a id="10196" href="VecMat.html#10196" class="Bound">M′</a> <a id="10199" href="VecMat.html#10199" class="Bound">N</a> <a id="10201" href="VecMat.html#10201" class="Bound">N′</a> <a id="10204" class="Symbol">:</a> <a id="10206" href="VecMat.html#3487" class="Function">Mat</a> <a id="10210" class="Symbol">_</a> <a id="10212" href="VecMat.html#2729" class="Generalizable">m</a> <a id="10214" href="VecMat.html#2731" class="Generalizable">n</a><a id="10215" class="Symbol">}</a> <a id="10217" class="Symbol">→</a> <a id="10219" href="VecMat.html#10194" class="Bound">M</a> <a id="10221" href="VecMat.html#9695" class="Function Operator">≈ₘ</a> <a id="10224" href="VecMat.html#10196" class="Bound">M′</a> <a id="10227" class="Symbol">→</a> <a id="10229" href="VecMat.html#10199" class="Bound">N</a> <a id="10231" href="VecMat.html#9695" class="Function Operator">≈ₘ</a> <a id="10234" href="VecMat.html#10201" class="Bound">N′</a> <a id="10237" class="Symbol">→</a> <a id="10239" href="VecMat.html#10194" class="Bound">M</a> <a id="10241" href="VecMat.html#8619" class="Function Operator">+ₘ</a> <a id="10244" href="VecMat.html#10199" class="Bound">N</a> <a id="10246" href="VecMat.html#9695" class="Function Operator">≈ₘ</a> <a id="10249" href="VecMat.html#10196" class="Bound">M′</a> <a id="10252" href="VecMat.html#8619" class="Function Operator">+ₘ</a> <a id="10255" href="VecMat.html#10201" class="Bound">N′</a>
    <a id="10262" href="VecMat.html#10183" class="Function">+ₘ-cong</a> <a id="10270" class="Symbol">=</a> <a id="10272" href="VecMat.html#6515" class="Function">Pw-zip</a> <a id="10279" href="VecMat.html#10077" class="Function">+ᵥ-cong</a>

    <a id="Naïve.WithSemiring.⊗ₒ-cong"></a><a id="10292" href="VecMat.html#10292" class="Function">⊗ₒ-cong</a> <a id="10300" class="Symbol">:</a> <a id="10302" class="Symbol">{</a><a id="10303" href="VecMat.html#10303" class="Bound">u</a> <a id="10305" href="VecMat.html#10305" class="Bound">u′</a> <a id="10308" class="Symbol">:</a> <a id="10310" href="VecMat.html#3054" class="Datatype">Vec</a> <a id="10314" class="Symbol">_</a> <a id="10316" href="VecMat.html#2729" class="Generalizable">m</a><a id="10317" class="Symbol">}</a> <a id="10319" class="Symbol">{</a><a id="10320" href="VecMat.html#10320" class="Bound">v</a> <a id="10322" href="VecMat.html#10322" class="Bound">v′</a> <a id="10325" class="Symbol">:</a> <a id="10327" href="VecMat.html#3054" class="Datatype">Vec</a> <a id="10331" class="Symbol">_</a> <a id="10333" href="VecMat.html#2731" class="Generalizable">n</a><a id="10334" class="Symbol">}</a> <a id="10336" class="Symbol">→</a>
              <a id="10352" href="VecMat.html#10303" class="Bound">u</a> <a id="10354" href="VecMat.html#9635" class="Function Operator">≈ᵥ</a> <a id="10357" href="VecMat.html#10305" class="Bound">u′</a> <a id="10360" class="Symbol">→</a> <a id="10362" href="VecMat.html#10320" class="Bound">v</a> <a id="10364" href="VecMat.html#9635" class="Function Operator">≈ᵥ</a> <a id="10367" href="VecMat.html#10322" class="Bound">v′</a> <a id="10370" class="Symbol">→</a> <a id="10372" href="VecMat.html#10303" class="Bound">u</a> <a id="10374" href="VecMat.html#8802" class="Function Operator">⊗ₒ</a> <a id="10377" href="VecMat.html#10320" class="Bound">v</a> <a id="10379" href="VecMat.html#9695" class="Function Operator">≈ₘ</a> <a id="10382" href="VecMat.html#10305" class="Bound">u′</a> <a id="10385" href="VecMat.html#8802" class="Function Operator">⊗ₒ</a> <a id="10388" href="VecMat.html#10322" class="Bound">v′</a>
    <a id="10395" href="VecMat.html#10292" class="Function">⊗ₒ-cong</a> <a id="10403" class="Symbol">=</a> <a id="10405" href="VecMat.html#6803" class="Function">Pw-outer</a> <a id="10414" href="Algebra.Structures.html#1078" class="Function">*-cong</a>

    <a id="Naïve.WithSemiring.+ᵥ-identityˡ"></a><a id="10426" href="VecMat.html#10426" class="Function">+ᵥ-identityˡ</a> <a id="10439" class="Symbol">:</a> <a id="10441" class="Symbol">(</a><a id="10442" href="VecMat.html#10442" class="Bound">u</a> <a id="10444" class="Symbol">:</a> <a id="10446" href="VecMat.html#3054" class="Datatype">Vec</a> <a id="10450" class="Symbol">_</a> <a id="10452" href="VecMat.html#2729" class="Generalizable">m</a><a id="10453" class="Symbol">)</a> <a id="10455" class="Symbol">→</a> <a id="10457" href="VecMat.html#8302" class="Function">0ᵥ</a> <a id="10460" href="VecMat.html#8348" class="Function Operator">+ᵥ</a> <a id="10463" href="VecMat.html#10442" class="Bound">u</a> <a id="10465" href="VecMat.html#9635" class="Function Operator">≈ᵥ</a> <a id="10468" href="VecMat.html#10442" class="Bound">u</a>
    <a id="10474" href="VecMat.html#10426" class="Function">+ᵥ-identityˡ</a> <a id="10487" href="VecMat.html#3098" class="InductiveConstructor">[]</a> <a id="10490" class="Symbol">=</a> <a id="10492" href="VecMat.html#3792" class="InductiveConstructor">[]</a>
    <a id="10499" href="VecMat.html#10426" class="Function">+ᵥ-identityˡ</a> <a id="10512" class="Symbol">(</a><a id="10513" href="VecMat.html#10513" class="Bound">x</a> <a id="10515" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="10517" href="VecMat.html#10517" class="Bound">u</a><a id="10518" class="Symbol">)</a> <a id="10520" class="Symbol">=</a> <a id="10522" href="Algebra.Structures.html#2610" class="Function">+-identityˡ</a> <a id="10534" href="VecMat.html#10513" class="Bound">x</a> <a id="10536" href="VecMat.html#3812" class="InductiveConstructor Operator">∷</a> <a id="10538" href="VecMat.html#10426" class="Function">+ᵥ-identityˡ</a> <a id="10551" href="VecMat.html#10517" class="Bound">u</a>

    <a id="Naïve.WithSemiring.+ᵥ-identityʳ"></a><a id="10558" href="VecMat.html#10558" class="Function">+ᵥ-identityʳ</a> <a id="10571" class="Symbol">:</a> <a id="10573" class="Symbol">(</a><a id="10574" href="VecMat.html#10574" class="Bound">u</a> <a id="10576" class="Symbol">:</a> <a id="10578" href="VecMat.html#3054" class="Datatype">Vec</a> <a id="10582" class="Symbol">_</a> <a id="10584" href="VecMat.html#2729" class="Generalizable">m</a><a id="10585" class="Symbol">)</a> <a id="10587" class="Symbol">→</a> <a id="10589" href="VecMat.html#10574" class="Bound">u</a> <a id="10591" href="VecMat.html#8348" class="Function Operator">+ᵥ</a> <a id="10594" href="VecMat.html#8302" class="Function">0ᵥ</a> <a id="10597" href="VecMat.html#9635" class="Function Operator">≈ᵥ</a> <a id="10600" href="VecMat.html#10574" class="Bound">u</a>
    <a id="10606" href="VecMat.html#10558" class="Function">+ᵥ-identityʳ</a> <a id="10619" href="VecMat.html#3098" class="InductiveConstructor">[]</a> <a id="10622" class="Symbol">=</a> <a id="10624" href="VecMat.html#3792" class="InductiveConstructor">[]</a>
    <a id="10631" href="VecMat.html#10558" class="Function">+ᵥ-identityʳ</a> <a id="10644" class="Symbol">(</a><a id="10645" href="VecMat.html#10645" class="Bound">x</a> <a id="10647" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="10649" href="VecMat.html#10649" class="Bound">u</a><a id="10650" class="Symbol">)</a> <a id="10652" class="Symbol">=</a> <a id="10654" href="Algebra.Structures.html#2715" class="Function">+-identityʳ</a> <a id="10666" href="VecMat.html#10645" class="Bound">x</a> <a id="10668" href="VecMat.html#3812" class="InductiveConstructor Operator">∷</a> <a id="10670" href="VecMat.html#10558" class="Function">+ᵥ-identityʳ</a> <a id="10683" href="VecMat.html#10649" class="Bound">u</a>

    <a id="Naïve.WithSemiring.*ᵥ-identityˡ"></a><a id="10690" href="VecMat.html#10690" class="Function">*ᵥ-identityˡ</a> <a id="10703" class="Symbol">:</a> <a id="10705" class="Symbol">∀</a> <a id="10707" class="Symbol">{</a><a id="10708" href="VecMat.html#10708" class="Bound">n</a><a id="10709" class="Symbol">}</a> <a id="10711" class="Symbol">(</a><a id="10712" href="VecMat.html#10712" class="Bound">u</a> <a id="10714" class="Symbol">:</a> <a id="10716" href="VecMat.html#3054" class="Datatype">Vec</a> <a id="10720" href="Algebra.html#12160" class="Field">Carrier</a> <a id="10728" href="VecMat.html#10708" class="Bound">n</a><a id="10729" class="Symbol">)</a> <a id="10731" class="Symbol">→</a> <a id="10733" href="Algebra.html#12297" class="Field">1#</a> <a id="10736" href="VecMat.html#8417" class="Function Operator">*ᵥ</a> <a id="10739" href="VecMat.html#10712" class="Bound">u</a> <a id="10741" href="VecMat.html#9635" class="Function Operator">≈ᵥ</a> <a id="10744" href="VecMat.html#10712" class="Bound">u</a>
    <a id="10750" href="VecMat.html#10690" class="Function">*ᵥ-identityˡ</a> <a id="10763" href="VecMat.html#3098" class="InductiveConstructor">[]</a> <a id="10766" class="Symbol">=</a> <a id="10768" href="VecMat.html#3792" class="InductiveConstructor">[]</a>
    <a id="10775" href="VecMat.html#10690" class="Function">*ᵥ-identityˡ</a> <a id="10788" class="Symbol">(</a><a id="10789" href="VecMat.html#10789" class="Bound">x</a> <a id="10791" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="10793" href="VecMat.html#10793" class="Bound">u</a><a id="10794" class="Symbol">)</a> <a id="10796" class="Symbol">=</a> <a id="10798" href="Algebra.Structures.html#2377" class="Function">*-identityˡ</a> <a id="10810" href="VecMat.html#10789" class="Bound">x</a> <a id="10812" href="VecMat.html#3812" class="InductiveConstructor Operator">∷</a> <a id="10814" href="VecMat.html#10690" class="Function">*ᵥ-identityˡ</a> <a id="10827" href="VecMat.html#10793" class="Bound">u</a>

    <a id="Naïve.WithSemiring.*ᵥ-zeroˡ"></a><a id="10834" href="VecMat.html#10834" class="Function">*ᵥ-zeroˡ</a> <a id="10843" class="Symbol">:</a> <a id="10845" class="Symbol">∀</a> <a id="10847" class="Symbol">{</a><a id="10848" href="VecMat.html#10848" class="Bound">n</a><a id="10849" class="Symbol">}</a> <a id="10851" class="Symbol">(</a><a id="10852" href="VecMat.html#10852" class="Bound">u</a> <a id="10854" class="Symbol">:</a> <a id="10856" href="VecMat.html#3054" class="Datatype">Vec</a> <a id="10860" href="Algebra.html#12160" class="Field">Carrier</a> <a id="10868" href="VecMat.html#10848" class="Bound">n</a><a id="10869" class="Symbol">)</a> <a id="10871" class="Symbol">→</a> <a id="10873" href="Algebra.html#12272" class="Field">0#</a> <a id="10876" href="VecMat.html#8417" class="Function Operator">*ᵥ</a> <a id="10879" href="VecMat.html#10852" class="Bound">u</a> <a id="10881" href="VecMat.html#9635" class="Function Operator">≈ᵥ</a> <a id="10884" href="VecMat.html#8302" class="Function">0ᵥ</a>
    <a id="10891" href="VecMat.html#10834" class="Function">*ᵥ-zeroˡ</a> <a id="10900" href="VecMat.html#3098" class="InductiveConstructor">[]</a> <a id="10903" class="Symbol">=</a> <a id="10905" href="VecMat.html#3792" class="InductiveConstructor">[]</a>
    <a id="10912" href="VecMat.html#10834" class="Function">*ᵥ-zeroˡ</a> <a id="10921" class="Symbol">(</a><a id="10922" href="VecMat.html#10922" class="Bound">x</a> <a id="10924" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="10926" href="VecMat.html#10926" class="Bound">u</a><a id="10927" class="Symbol">)</a> <a id="10929" class="Symbol">=</a> <a id="10931" href="Algebra.Structures.html#7988" class="Function">zeroˡ</a> <a id="10937" href="VecMat.html#10922" class="Bound">x</a> <a id="10939" href="VecMat.html#3812" class="InductiveConstructor Operator">∷</a> <a id="10941" href="VecMat.html#10834" class="Function">*ᵥ-zeroˡ</a> <a id="10950" href="VecMat.html#10926" class="Bound">u</a>

    <a id="Naïve.WithSemiring.+ₘ-identityˡ"></a><a id="10957" href="VecMat.html#10957" class="Function">+ₘ-identityˡ</a> <a id="10970" class="Symbol">:</a> <a id="10972" class="Symbol">(</a><a id="10973" href="VecMat.html#10973" class="Bound">M</a> <a id="10975" class="Symbol">:</a> <a id="10977" href="VecMat.html#3487" class="Function">Mat</a> <a id="10981" class="Symbol">_</a> <a id="10983" href="VecMat.html#2729" class="Generalizable">m</a> <a id="10985" href="VecMat.html#2731" class="Generalizable">n</a><a id="10986" class="Symbol">)</a> <a id="10988" class="Symbol">→</a> <a id="10990" href="VecMat.html#8571" class="Function">0ₘ</a> <a id="10993" href="VecMat.html#8619" class="Function Operator">+ₘ</a> <a id="10996" href="VecMat.html#10973" class="Bound">M</a> <a id="10998" href="VecMat.html#9695" class="Function Operator">≈ₘ</a> <a id="11001" href="VecMat.html#10973" class="Bound">M</a>
    <a id="11007" href="VecMat.html#10957" class="Function">+ₘ-identityˡ</a> <a id="11020" href="VecMat.html#3098" class="InductiveConstructor">[]</a> <a id="11023" class="Symbol">=</a> <a id="11025" href="VecMat.html#3792" class="InductiveConstructor">[]</a>
    <a id="11032" href="VecMat.html#10957" class="Function">+ₘ-identityˡ</a> <a id="11045" class="Symbol">(</a><a id="11046" href="VecMat.html#11046" class="Bound">u</a> <a id="11048" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="11050" href="VecMat.html#11050" class="Bound">M</a><a id="11051" class="Symbol">)</a> <a id="11053" class="Symbol">=</a> <a id="11055" href="VecMat.html#10426" class="Function">+ᵥ-identityˡ</a> <a id="11068" href="VecMat.html#11046" class="Bound">u</a> <a id="11070" href="VecMat.html#3812" class="InductiveConstructor Operator">∷</a> <a id="11072" href="VecMat.html#10957" class="Function">+ₘ-identityˡ</a> <a id="11085" href="VecMat.html#11050" class="Bound">M</a>

    <a id="Naïve.WithSemiring.⊗ₒ-zeroˡ"></a><a id="11092" href="VecMat.html#11092" class="Function">⊗ₒ-zeroˡ</a> <a id="11101" class="Symbol">:</a> <a id="11103" class="Symbol">(</a><a id="11104" href="VecMat.html#11104" class="Bound">v</a> <a id="11106" class="Symbol">:</a> <a id="11108" href="VecMat.html#3054" class="Datatype">Vec</a> <a id="11112" class="Symbol">_</a> <a id="11114" href="VecMat.html#2731" class="Generalizable">n</a><a id="11115" class="Symbol">)</a> <a id="11117" class="Symbol">→</a> <a id="11119" href="VecMat.html#8302" class="Function">0ᵥ</a> <a id="11122" class="Symbol">{</a><a id="11123" href="VecMat.html#2729" class="Generalizable">m</a><a id="11124" class="Symbol">}</a> <a id="11126" href="VecMat.html#8802" class="Function Operator">⊗ₒ</a> <a id="11129" href="VecMat.html#11104" class="Bound">v</a> <a id="11131" href="VecMat.html#9695" class="Function Operator">≈ₘ</a> <a id="11134" href="VecMat.html#8571" class="Function">0ₘ</a>
    <a id="11141" href="VecMat.html#11092" class="Function">⊗ₒ-zeroˡ</a> <a id="11150" class="Symbol">{</a><a id="11151" class="Argument">m</a> <a id="11153" class="Symbol">=</a> <a id="11155" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a><a id="11159" class="Symbol">}</a> <a id="11161" href="VecMat.html#11161" class="Bound">v</a> <a id="11163" class="Symbol">=</a> <a id="11165" href="VecMat.html#3792" class="InductiveConstructor">[]</a>
    <a id="11172" href="VecMat.html#11092" class="Function">⊗ₒ-zeroˡ</a> <a id="11181" class="Symbol">{</a><a id="11182" class="Argument">m</a> <a id="11184" class="Symbol">=</a> <a id="11186" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="11190" href="VecMat.html#11190" class="Bound">m</a><a id="11191" class="Symbol">}</a> <a id="11193" href="VecMat.html#11193" class="Bound">v</a> <a id="11195" class="Symbol">=</a> <a id="11197" href="VecMat.html#10834" class="Function">*ᵥ-zeroˡ</a> <a id="11206" href="VecMat.html#11193" class="Bound">v</a> <a id="11208" href="VecMat.html#3812" class="InductiveConstructor Operator">∷</a> <a id="11210" href="VecMat.html#11092" class="Function">⊗ₒ-zeroˡ</a> <a id="11219" href="VecMat.html#11193" class="Bound">v</a>
</pre>-->
<p>We want to prove that <code>1ₘ</code> is the unit of <code>_*ₘ_</code>. Our approach is to follow the definition of <code>_*ₘ_</code> and do induction on <code>M</code>. This conveniently tells us something about the dimension <code>m</code>, allowing <code>1ₘ</code> to compute.</p>
<pre class="Agda">    <a id="Naïve.WithSemiring.*ₘ-identityˡ"></a><a id="11457" href="VecMat.html#11457" class="Function">*ₘ-identityˡ</a> <a id="11470" class="Symbol">:</a> <a id="11472" class="Symbol">(</a><a id="11473" href="VecMat.html#11473" class="Bound">M</a> <a id="11475" class="Symbol">:</a> <a id="11477" href="VecMat.html#3487" class="Function">Mat</a> <a id="11481" href="Algebra.html#12160" class="Field">Carrier</a> <a id="11489" href="VecMat.html#2729" class="Generalizable">m</a> <a id="11491" href="VecMat.html#2731" class="Generalizable">n</a><a id="11492" class="Symbol">)</a> <a id="11494" class="Symbol">→</a> <a id="11496" href="VecMat.html#8693" class="Function">1ₘ</a> <a id="11499" href="VecMat.html#8883" class="Function Operator">*ₘ</a> <a id="11502" href="VecMat.html#11473" class="Bound">M</a> <a id="11504" href="VecMat.html#9695" class="Function Operator">≈ₘ</a> <a id="11507" href="VecMat.html#11473" class="Bound">M</a>
    <a id="11513" href="VecMat.html#11457" class="Function">*ₘ-identityˡ</a> <a id="11526" href="VecMat.html#3098" class="InductiveConstructor">[]</a> <a id="11529" class="Symbol">=</a> <a id="11531" href="VecMat.html#3792" class="InductiveConstructor">[]</a>
    <a id="11538" href="VecMat.html#11457" class="Function">*ₘ-identityˡ</a> <a id="11551" class="Symbol">(</a><a id="11552" href="VecMat.html#11552" class="Bound">u</a> <a id="11554" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="11556" href="VecMat.html#11556" class="Bound">M</a><a id="11557" class="Symbol">)</a> <a id="11559" class="Symbol">=</a> <a id="11561" href="Relation.Binary.Reasoning.Base.Single.html#859" class="Function Operator">begin</a>
      <a id="11573" href="VecMat.html#8693" class="Function">1ₘ</a> <a id="11576" href="VecMat.html#8883" class="Function Operator">*ₘ</a> <a id="11579" class="Symbol">(</a><a id="11580" href="VecMat.html#11552" class="Bound">u</a> <a id="11582" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="11584" href="VecMat.html#11556" class="Bound">M</a><a id="11585" class="Symbol">)</a>  <a id="11588" href="Relation.Binary.Reasoning.Base.Single.html#1212" class="Function Operator">≡⟨⟩</a>
      <a id="11598" class="Symbol">(</a><a id="11599" href="Algebra.html#12297" class="Field">1#</a> <a id="11602" href="VecMat.html#8417" class="Function Operator">*ᵥ</a> <a id="11605" href="VecMat.html#11552" class="Bound">u</a> <a id="11607" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="11609" href="Agda.Builtin.Sigma.html#225" class="Field">proj₁</a> <a id="11615" class="Symbol">(</a><a id="11616" href="VecMat.html#7515" class="Function">left/rest</a> <a id="11626" class="Symbol">(</a><a id="11627" href="VecMat.html#4899" class="Function">map</a> <a id="11631" class="Symbol">(</a><a id="11632" href="Algebra.html#12272" class="Field">0#</a> <a id="11635" href="VecMat.html#3118" class="InductiveConstructor Operator">∷_</a><a id="11637" class="Symbol">)</a> <a id="11639" href="VecMat.html#8693" class="Function">1ₘ</a><a id="11641" class="Symbol">))</a> <a id="11644" href="VecMat.html#8802" class="Function Operator">⊗ₒ</a> <a id="11647" href="VecMat.html#11552" class="Bound">u</a><a id="11648" class="Symbol">)</a>
        <a id="11658" href="VecMat.html#8619" class="Function Operator">+ₘ</a> <a id="11661" class="Symbol">(</a><a id="11662" href="VecMat.html#8302" class="Function">0ᵥ</a> <a id="11665" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="11667" href="Agda.Builtin.Sigma.html#237" class="Field">proj₂</a> <a id="11673" class="Symbol">(</a><a id="11674" href="VecMat.html#7515" class="Function">left/rest</a> <a id="11684" class="Symbol">(</a><a id="11685" href="VecMat.html#4899" class="Function">map</a> <a id="11689" class="Symbol">(</a><a id="11690" href="Algebra.html#12272" class="Field">0#</a> <a id="11693" href="VecMat.html#3118" class="InductiveConstructor Operator">∷_</a><a id="11695" class="Symbol">)</a> <a id="11697" href="VecMat.html#8693" class="Function">1ₘ</a><a id="11699" class="Symbol">)))</a> <a id="11703" href="VecMat.html#8883" class="Function Operator">*ₘ</a> <a id="11706" href="VecMat.html#11556" class="Bound">M</a>
        <a id="11716" href="Relation.Binary.Reasoning.Base.Single.html#925" class="Function Operator">≈⟨</a> <a id="11719" class="Symbol">(</a><a id="11720" class="Keyword">let</a> <a id="11724" href="VecMat.html#11724" class="Bound">q</a> <a id="11726" class="Symbol">=</a> <a id="11728" href="VecMat.html#7838" class="Function">left/rest-map-∷</a> <a id="11744" href="Algebra.html#12272" class="Field">0#</a> <a id="11747" href="VecMat.html#8693" class="Function">1ₘ</a> <a id="11750" class="Keyword">in</a>
            <a id="11765" href="VecMat.html#10183" class="Function">+ₘ-cong</a>
              <a id="11787" class="Symbol">(</a><a id="11788" href="VecMat.html#10690" class="Function">*ᵥ-identityˡ</a> <a id="11801" href="VecMat.html#11552" class="Bound">u</a>
               <a id="11818" href="VecMat.html#3812" class="InductiveConstructor Operator">∷</a> <a id="11820" href="VecMat.html#10292" class="Function">⊗ₒ-cong</a> <a id="11828" class="Symbol">(</a><a id="11829" href="VecMat.html#5713" class="Function">pw</a> <a id="11832" href="Relation.Binary.Core.html#7098" class="Function">reflexive</a> <a id="11842" class="Symbol">(</a><a id="11843" href="VecMat.html#7126" class="Function">≡⇒Pw-≡</a> <a id="11850" class="Symbol">(</a><a id="11851" href="Relation.Binary.PropositionalEquality.Core.html#1090" class="Function">≡.cong</a> <a id="11858" href="Agda.Builtin.Sigma.html#225" class="Field">proj₁</a> <a id="11864" href="VecMat.html#11724" class="Bound">q</a><a id="11865" class="Symbol">)))</a> <a id="11869" href="VecMat.html#9775" class="Function">reflᵥ</a><a id="11874" class="Symbol">)</a>
              <a id="11890" class="Symbol">(</a><a id="11891" href="VecMat.html#5713" class="Function">pw</a> <a id="11894" class="Symbol">(</a><a id="11895" href="VecMat.html#5713" class="Function">pw</a> <a id="11898" href="Relation.Binary.Core.html#7098" class="Function">reflexive</a><a id="11907" class="Symbol">)</a>
                  <a id="11927" class="Symbol">(</a><a id="11928" href="VecMat.html#5713" class="Function">pw</a> <a id="11931" href="VecMat.html#7126" class="Function">≡⇒Pw-≡</a> <a id="11938" class="Symbol">(</a><a id="11939" href="VecMat.html#7126" class="Function">≡⇒Pw-≡</a> <a id="11946" class="Symbol">(</a><a id="11947" href="Relation.Binary.PropositionalEquality.Core.html#1090" class="Function">≡.cong</a> <a id="11954" class="Symbol">(λ</a> <a id="11957" href="VecMat.html#11957" class="Bound">z</a> <a id="11959" class="Symbol">→</a> <a id="11961" class="Symbol">(</a><a id="11962" href="VecMat.html#8302" class="Function">0ᵥ</a> <a id="11965" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="11967" href="VecMat.html#11957" class="Bound">z</a><a id="11968" class="Symbol">)</a> <a id="11970" href="VecMat.html#8883" class="Function Operator">*ₘ</a> <a id="11973" href="VecMat.html#11556" class="Bound">M</a><a id="11974" class="Symbol">)</a>
                                             <a id="12021" class="Symbol">(</a><a id="12022" href="Relation.Binary.PropositionalEquality.Core.html#1090" class="Function">≡.cong</a> <a id="12029" href="Agda.Builtin.Sigma.html#237" class="Field">proj₂</a> <a id="12035" href="VecMat.html#11724" class="Bound">q</a><a id="12036" class="Symbol">))))))</a> <a id="12043" href="Relation.Binary.Reasoning.Base.Single.html#925" class="Function Operator">⟩</a>
      <a id="12051" class="Symbol">(</a><a id="12052" href="VecMat.html#11552" class="Bound">u</a> <a id="12054" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="12056" href="VecMat.html#8302" class="Function">0ᵥ</a> <a id="12059" href="VecMat.html#8802" class="Function Operator">⊗ₒ</a> <a id="12062" href="VecMat.html#11552" class="Bound">u</a><a id="12063" class="Symbol">)</a> <a id="12065" href="VecMat.html#8619" class="Function Operator">+ₘ</a> <a id="12068" class="Symbol">(</a><a id="12069" href="VecMat.html#8302" class="Function">0ᵥ</a> <a id="12072" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="12074" href="VecMat.html#8693" class="Function">1ₘ</a><a id="12076" class="Symbol">)</a> <a id="12078" href="VecMat.html#8883" class="Function Operator">*ₘ</a> <a id="12081" href="VecMat.html#11556" class="Bound">M</a>
        <a id="12091" href="Relation.Binary.Reasoning.Base.Single.html#925" class="Function Operator">≈⟨</a> <a id="12094" href="VecMat.html#10183" class="Function">+ₘ-cong</a> <a id="12102" class="Symbol">(</a><a id="12103" href="VecMat.html#9775" class="Function">reflᵥ</a> <a id="12109" href="VecMat.html#3812" class="InductiveConstructor Operator">∷</a> <a id="12111" href="VecMat.html#11092" class="Function">⊗ₒ-zeroˡ</a> <a id="12120" href="VecMat.html#11552" class="Bound">u</a><a id="12121" class="Symbol">)</a>
                   <a id="12142" class="Symbol">(</a><a id="12143" href="VecMat.html#9987" class="Function">transₘ</a> <a id="12150" class="Symbol">(</a><a id="12151" href="VecMat.html#12460" class="Function">lemma0</a> <a id="12158" href="VecMat.html#8302" class="Function">0ᵥ</a> <a id="12161" href="VecMat.html#8693" class="Function">1ₘ</a> <a id="12164" href="VecMat.html#11556" class="Bound">M</a><a id="12165" class="Symbol">)</a> <a id="12167" class="Symbol">(</a><a id="12168" href="VecMat.html#13101" class="Function">lemma1</a> <a id="12175" href="VecMat.html#11556" class="Bound">M</a> <a id="12177" href="VecMat.html#6099" class="Function Operator">Pw-++</a> <a id="12183" href="VecMat.html#9836" class="Function">reflₘ</a><a id="12188" class="Symbol">))</a> <a id="12191" href="Relation.Binary.Reasoning.Base.Single.html#925" class="Function Operator">⟩</a>
      <a id="12199" class="Symbol">(</a><a id="12200" href="VecMat.html#11552" class="Bound">u</a> <a id="12202" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="12204" href="VecMat.html#8571" class="Function">0ₘ</a><a id="12206" class="Symbol">)</a> <a id="12208" href="VecMat.html#8619" class="Function Operator">+ₘ</a> <a id="12211" class="Symbol">(</a><a id="12212" href="VecMat.html#8302" class="Function">0ᵥ</a> <a id="12215" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="12217" href="VecMat.html#8693" class="Function">1ₘ</a> <a id="12220" href="VecMat.html#8883" class="Function Operator">*ₘ</a> <a id="12223" href="VecMat.html#11556" class="Bound">M</a><a id="12224" class="Symbol">)</a>
        <a id="12234" href="Relation.Binary.Reasoning.Base.Single.html#1212" class="Function Operator">≡⟨⟩</a>
      <a id="12244" href="VecMat.html#11552" class="Bound">u</a> <a id="12246" href="VecMat.html#8348" class="Function Operator">+ᵥ</a> <a id="12249" href="VecMat.html#8302" class="Function">0ᵥ</a> <a id="12252" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="12254" href="VecMat.html#8571" class="Function">0ₘ</a> <a id="12257" href="VecMat.html#8619" class="Function Operator">+ₘ</a> <a id="12260" href="VecMat.html#8693" class="Function">1ₘ</a> <a id="12263" href="VecMat.html#8883" class="Function Operator">*ₘ</a> <a id="12266" href="VecMat.html#11556" class="Bound">M</a>
        <a id="12276" href="Relation.Binary.Reasoning.Base.Single.html#925" class="Function Operator">≈⟨</a> <a id="12279" href="VecMat.html#10558" class="Function">+ᵥ-identityʳ</a> <a id="12292" href="VecMat.html#11552" class="Bound">u</a> <a id="12294" href="VecMat.html#3812" class="InductiveConstructor Operator">∷</a> <a id="12296" href="VecMat.html#9987" class="Function">transₘ</a> <a id="12303" class="Symbol">(</a><a id="12304" href="VecMat.html#10957" class="Function">+ₘ-identityˡ</a> <a id="12317" class="Symbol">(</a><a id="12318" href="VecMat.html#8693" class="Function">1ₘ</a> <a id="12321" href="VecMat.html#8883" class="Function Operator">*ₘ</a> <a id="12324" href="VecMat.html#11556" class="Bound">M</a><a id="12325" class="Symbol">))</a> <a id="12328" class="Symbol">(</a><a id="12329" href="VecMat.html#11457" class="Function">*ₘ-identityˡ</a> <a id="12342" href="VecMat.html#11556" class="Bound">M</a><a id="12343" class="Symbol">)</a> <a id="12345" href="Relation.Binary.Reasoning.Base.Single.html#925" class="Function Operator">⟩</a>
      <a id="12353" href="VecMat.html#11552" class="Bound">u</a> <a id="12355" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="12357" href="VecMat.html#11556" class="Bound">M</a>  <a id="12360" href="Relation.Binary.Reasoning.Base.Single.html#1295" class="Function Operator">∎</a>
      <a id="12368" class="Keyword">where</a>
      <a id="12380" class="Keyword">open</a> <a id="12385" class="Keyword">module</a> <a id="R"></a><a id="12392" href="VecMat.html#12392" class="Module">R</a> <a id="12394" class="Symbol">{</a><a id="12395" href="VecMat.html#12395" class="Bound">m</a> <a id="12397" href="VecMat.html#12397" class="Bound">n</a><a id="12398" class="Symbol">}</a> <a id="12400" class="Symbol">=</a> <a id="12402" href="Relation.Binary.Reasoning.Setoid.html" class="Module">SetoidReasoning</a> <a id="12418" class="Symbol">(</a><a id="12419" href="VecMat.html#4335" class="Function">Pw-setoid</a> <a id="12429" class="Symbol">(</a><a id="12430" href="VecMat.html#4335" class="Function">Pw-setoid</a> <a id="12440" href="Algebra.Structures.html#1153" class="Function">setoid</a> <a id="12447" href="VecMat.html#12397" class="Bound">n</a><a id="12448" class="Symbol">)</a> <a id="12450" href="VecMat.html#12395" class="Bound">m</a><a id="12451" class="Symbol">)</a>

      <a id="12460" href="VecMat.html#12460" class="Function">lemma0</a> <a id="12467" class="Symbol">:</a> <a id="12469" class="Symbol">(</a><a id="12470" href="VecMat.html#12470" class="Bound">u</a> <a id="12472" class="Symbol">:</a> <a id="12474" href="VecMat.html#3054" class="Datatype">Vec</a> <a id="12478" class="Symbol">_</a> <a id="12480" href="VecMat.html#2731" class="Generalizable">n</a><a id="12481" class="Symbol">)</a> <a id="12483" class="Symbol">(</a><a id="12484" href="VecMat.html#12484" class="Bound">M</a> <a id="12486" class="Symbol">:</a> <a id="12488" href="VecMat.html#3487" class="Function">Mat</a> <a id="12492" class="Symbol">_</a> <a id="12494" href="VecMat.html#2729" class="Generalizable">m</a> <a id="12496" href="VecMat.html#2731" class="Generalizable">n</a><a id="12497" class="Symbol">)</a> <a id="12499" class="Symbol">(</a><a id="12500" href="VecMat.html#12500" class="Bound">N</a> <a id="12502" class="Symbol">:</a> <a id="12504" href="VecMat.html#3487" class="Function">Mat</a> <a id="12508" class="Symbol">_</a> <a id="12510" href="VecMat.html#2731" class="Generalizable">n</a> <a id="12512" href="VecMat.html#2733" class="Generalizable">o</a><a id="12513" class="Symbol">)</a> <a id="12515" class="Symbol">→</a>
               <a id="12532" class="Symbol">(</a><a id="12533" href="VecMat.html#12470" class="Bound">u</a> <a id="12535" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="12537" href="VecMat.html#12484" class="Bound">M</a><a id="12538" class="Symbol">)</a> <a id="12540" href="VecMat.html#8883" class="Function Operator">*ₘ</a> <a id="12543" href="VecMat.html#12500" class="Bound">N</a> <a id="12545" href="VecMat.html#9695" class="Function Operator">≈ₘ</a> <a id="12548" class="Symbol">(</a><a id="12549" href="VecMat.html#12470" class="Bound">u</a> <a id="12551" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="12553" href="VecMat.html#3098" class="InductiveConstructor">[]</a><a id="12555" class="Symbol">)</a> <a id="12557" href="VecMat.html#8883" class="Function Operator">*ₘ</a> <a id="12560" href="VecMat.html#12500" class="Bound">N</a> <a id="12562" href="VecMat.html#4988" class="Function Operator">++</a> <a id="12565" href="VecMat.html#12484" class="Bound">M</a> <a id="12567" href="VecMat.html#8883" class="Function Operator">*ₘ</a> <a id="12570" href="VecMat.html#12500" class="Bound">N</a>
      <a id="12578" href="VecMat.html#12460" class="Function">lemma0</a> <a id="12585" href="VecMat.html#12585" class="Bound">u</a> <a id="12587" href="VecMat.html#12587" class="Bound">M</a> <a id="12589" href="VecMat.html#3098" class="InductiveConstructor">[]</a> <a id="12592" class="Symbol">=</a> <a id="12594" href="VecMat.html#9836" class="Function">reflₘ</a>
      <a id="12606" href="VecMat.html#12460" class="Function">lemma0</a> <a id="12613" class="Symbol">(</a><a id="12614" href="VecMat.html#12614" class="Bound">x</a> <a id="12616" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="12618" href="VecMat.html#12618" class="Bound">u</a><a id="12619" class="Symbol">)</a> <a id="12621" href="VecMat.html#12621" class="Bound">vM</a> <a id="12624" class="Symbol">(</a><a id="12625" href="VecMat.html#12625" class="Bound">w</a> <a id="12627" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="12629" href="VecMat.html#12629" class="Bound">N</a><a id="12630" class="Symbol">)</a> <a id="12632" class="Keyword">with</a> <a id="12637" href="VecMat.html#7515" class="Function">left/rest</a> <a id="12647" href="VecMat.html#12621" class="Bound">vM</a>
      <a id="12656" class="Symbol">...</a> <a id="12660" class="Symbol">|</a> <a id="12662" href="VecMat.html#12662" class="Bound">v</a> <a id="12664" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="12666" href="VecMat.html#12666" class="Bound">M</a> <a id="12668" class="Symbol">=</a> <a id="12670" href="Relation.Binary.Reasoning.Base.Single.html#859" class="Function Operator">begin</a>
        <a id="12684" class="Symbol">(</a><a id="12685" class="Bound">x</a> <a id="12687" href="VecMat.html#8417" class="Function Operator">*ᵥ</a> <a id="12690" class="Bound">w</a> <a id="12692" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="12694" href="VecMat.html#12662" class="Bound">v</a> <a id="12696" href="VecMat.html#8802" class="Function Operator">⊗ₒ</a> <a id="12699" class="Bound">w</a><a id="12700" class="Symbol">)</a> <a id="12702" href="VecMat.html#8619" class="Function Operator">+ₘ</a> <a id="12705" class="Symbol">(</a><a id="12706" class="Bound">u</a> <a id="12708" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="12710" href="VecMat.html#12666" class="Bound">M</a><a id="12711" class="Symbol">)</a> <a id="12713" href="VecMat.html#8883" class="Function Operator">*ₘ</a> <a id="12716" class="Bound">N</a>  <a id="12719" href="Relation.Binary.Reasoning.Base.Single.html#925" class="Function Operator">≈⟨</a> <a id="12722" href="VecMat.html#10183" class="Function">+ₘ-cong</a> <a id="12730" href="VecMat.html#9836" class="Function">reflₘ</a> <a id="12736" class="Symbol">(</a><a id="12737" href="VecMat.html#12460" class="Function">lemma0</a> <a id="12744" class="Bound">u</a> <a id="12746" href="VecMat.html#12666" class="Bound">M</a> <a id="12748" class="Bound">N</a><a id="12749" class="Symbol">)</a> <a id="12751" href="Relation.Binary.Reasoning.Base.Single.html#925" class="Function Operator">⟩</a>
        <a id="12761" class="Symbol">(</a><a id="12762" class="Bound">x</a> <a id="12764" href="VecMat.html#8417" class="Function Operator">*ᵥ</a> <a id="12767" class="Bound">w</a> <a id="12769" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="12771" href="VecMat.html#12662" class="Bound">v</a> <a id="12773" href="VecMat.html#8802" class="Function Operator">⊗ₒ</a> <a id="12776" class="Bound">w</a><a id="12777" class="Symbol">)</a> <a id="12779" href="VecMat.html#8619" class="Function Operator">+ₘ</a> <a id="12782" class="Symbol">((</a><a id="12784" class="Bound">u</a> <a id="12786" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="12788" href="VecMat.html#3098" class="InductiveConstructor">[]</a><a id="12790" class="Symbol">)</a> <a id="12792" href="VecMat.html#8883" class="Function Operator">*ₘ</a> <a id="12795" class="Bound">N</a> <a id="12797" href="VecMat.html#4988" class="Function Operator">++</a> <a id="12800" href="VecMat.html#12666" class="Bound">M</a> <a id="12802" href="VecMat.html#8883" class="Function Operator">*ₘ</a> <a id="12805" class="Bound">N</a><a id="12806" class="Symbol">)</a>
          <a id="12818" href="Relation.Binary.Reasoning.Base.Single.html#925" class="Function Operator">≈⟨</a> <a id="12821" href="VecMat.html#12934" class="Function">pseudowith</a> <a id="12832" class="Symbol">((</a><a id="12834" class="Bound">u</a> <a id="12836" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="12838" href="VecMat.html#3098" class="InductiveConstructor">[]</a><a id="12840" class="Symbol">)</a> <a id="12842" href="VecMat.html#8883" class="Function Operator">*ₘ</a> <a id="12845" class="Bound">N</a><a id="12846" class="Symbol">)</a> <a id="12848" href="Relation.Binary.Reasoning.Base.Single.html#925" class="Function Operator">⟩</a>
        <a id="12858" class="Symbol">(</a><a id="12859" class="Bound">x</a> <a id="12861" href="VecMat.html#8417" class="Function Operator">*ᵥ</a> <a id="12864" class="Bound">w</a> <a id="12866" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="12868" href="VecMat.html#3098" class="InductiveConstructor">[]</a><a id="12870" class="Symbol">)</a> <a id="12872" href="VecMat.html#8619" class="Function Operator">+ₘ</a> <a id="12875" class="Symbol">(</a><a id="12876" class="Bound">u</a> <a id="12878" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="12880" href="VecMat.html#3098" class="InductiveConstructor">[]</a><a id="12882" class="Symbol">)</a> <a id="12884" href="VecMat.html#8883" class="Function Operator">*ₘ</a> <a id="12887" class="Bound">N</a> <a id="12889" href="VecMat.html#4988" class="Function Operator">++</a> <a id="12892" href="VecMat.html#12662" class="Bound">v</a> <a id="12894" href="VecMat.html#8802" class="Function Operator">⊗ₒ</a> <a id="12897" class="Bound">w</a> <a id="12899" href="VecMat.html#8619" class="Function Operator">+ₘ</a> <a id="12902" href="VecMat.html#12666" class="Bound">M</a> <a id="12904" href="VecMat.html#8883" class="Function Operator">*ₘ</a> <a id="12907" class="Bound">N</a>  <a id="12910" href="Relation.Binary.Reasoning.Base.Single.html#1295" class="Function Operator">∎</a>
        <a id="12920" class="Keyword">where</a>
        <a id="12934" href="VecMat.html#12934" class="Function">pseudowith</a> <a id="12945" class="Symbol">:</a> <a id="12947" class="Symbol">∀</a> <a id="12949" href="VecMat.html#12949" class="Bound">u*N</a> <a id="12953" class="Symbol">→</a>
          <a id="12965" class="Symbol">(</a><a id="12966" class="Bound">x</a> <a id="12968" href="VecMat.html#8417" class="Function Operator">*ᵥ</a> <a id="12971" class="Bound">w</a> <a id="12973" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="12975" href="VecMat.html#12662" class="Bound">v</a> <a id="12977" href="VecMat.html#8802" class="Function Operator">⊗ₒ</a> <a id="12980" class="Bound">w</a><a id="12981" class="Symbol">)</a> <a id="12983" href="VecMat.html#8619" class="Function Operator">+ₘ</a> <a id="12986" class="Symbol">(</a><a id="12987" href="VecMat.html#12949" class="Bound">u*N</a> <a id="12991" href="VecMat.html#4988" class="Function Operator">++</a> <a id="12994" href="VecMat.html#12666" class="Bound">M</a> <a id="12996" href="VecMat.html#8883" class="Function Operator">*ₘ</a> <a id="12999" class="Bound">N</a><a id="13000" class="Symbol">)</a> <a id="13002" href="VecMat.html#9695" class="Function Operator">≈ₘ</a>
          <a id="13015" class="Symbol">(</a><a id="13016" class="Bound">x</a> <a id="13018" href="VecMat.html#8417" class="Function Operator">*ᵥ</a> <a id="13021" class="Bound">w</a> <a id="13023" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="13025" href="VecMat.html#3098" class="InductiveConstructor">[]</a><a id="13027" class="Symbol">)</a> <a id="13029" href="VecMat.html#8619" class="Function Operator">+ₘ</a> <a id="13032" href="VecMat.html#12949" class="Bound">u*N</a> <a id="13036" href="VecMat.html#4988" class="Function Operator">++</a> <a id="13039" href="VecMat.html#12662" class="Bound">v</a> <a id="13041" href="VecMat.html#8802" class="Function Operator">⊗ₒ</a> <a id="13044" class="Bound">w</a> <a id="13046" href="VecMat.html#8619" class="Function Operator">+ₘ</a> <a id="13049" href="VecMat.html#12666" class="Bound">M</a> <a id="13051" href="VecMat.html#8883" class="Function Operator">*ₘ</a> <a id="13054" class="Bound">N</a>
        <a id="13064" href="VecMat.html#12934" class="Function">pseudowith</a> <a id="13075" class="Symbol">(</a><a id="13076" href="VecMat.html#13076" class="Bound">u*N</a> <a id="13080" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="13082" href="VecMat.html#3098" class="InductiveConstructor">[]</a><a id="13084" class="Symbol">)</a> <a id="13086" class="Symbol">=</a> <a id="13088" href="VecMat.html#9836" class="Function">reflₘ</a>

      <a id="13101" href="VecMat.html#13101" class="Function">lemma1</a> <a id="13108" class="Symbol">:</a> <a id="13110" class="Symbol">(</a><a id="13111" href="VecMat.html#13111" class="Bound">N</a> <a id="13113" class="Symbol">:</a> <a id="13115" href="VecMat.html#3487" class="Function">Mat</a> <a id="13119" class="Symbol">_</a> <a id="13121" href="VecMat.html#2729" class="Generalizable">m</a> <a id="13123" href="VecMat.html#2731" class="Generalizable">n</a><a id="13124" class="Symbol">)</a> <a id="13126" class="Symbol">→</a> <a id="13128" class="Symbol">(</a><a id="13129" href="VecMat.html#8302" class="Function">0ᵥ</a> <a id="13132" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="13134" href="VecMat.html#3098" class="InductiveConstructor">[]</a><a id="13136" class="Symbol">)</a> <a id="13138" href="VecMat.html#8883" class="Function Operator">*ₘ</a> <a id="13141" href="VecMat.html#13111" class="Bound">N</a> <a id="13143" href="VecMat.html#9695" class="Function Operator">≈ₘ</a> <a id="13146" href="VecMat.html#8302" class="Function">0ᵥ</a> <a id="13149" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="13151" href="VecMat.html#3098" class="InductiveConstructor">[]</a>
      <a id="13160" href="VecMat.html#13101" class="Function">lemma1</a> <a id="13167" href="VecMat.html#3098" class="InductiveConstructor">[]</a> <a id="13170" class="Symbol">=</a> <a id="13172" href="VecMat.html#9836" class="Function">reflₘ</a>
      <a id="13184" href="VecMat.html#13101" class="Function">lemma1</a> <a id="13191" class="Symbol">(</a><a id="13192" href="VecMat.html#13192" class="Bound">v</a> <a id="13194" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="13196" href="VecMat.html#13196" class="Bound">N</a><a id="13197" class="Symbol">)</a> <a id="13199" class="Symbol">=</a> <a id="13201" href="Relation.Binary.Reasoning.Base.Single.html#859" class="Function Operator">begin</a>
        <a id="13215" class="Symbol">(</a><a id="13216" href="Algebra.html#12272" class="Field">0#</a> <a id="13219" href="VecMat.html#8417" class="Function Operator">*ᵥ</a> <a id="13222" href="VecMat.html#13192" class="Bound">v</a> <a id="13224" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="13226" href="VecMat.html#3098" class="InductiveConstructor">[]</a><a id="13228" class="Symbol">)</a> <a id="13230" href="VecMat.html#8619" class="Function Operator">+ₘ</a> <a id="13233" class="Symbol">(</a><a id="13234" href="VecMat.html#8302" class="Function">0ᵥ</a> <a id="13237" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="13239" href="VecMat.html#3098" class="InductiveConstructor">[]</a><a id="13241" class="Symbol">)</a> <a id="13243" href="VecMat.html#8883" class="Function Operator">*ₘ</a> <a id="13246" href="VecMat.html#13196" class="Bound">N</a>
          <a id="13258" href="Relation.Binary.Reasoning.Base.Single.html#925" class="Function Operator">≈⟨</a> <a id="13261" href="VecMat.html#10183" class="Function">+ₘ-cong</a> <a id="13269" class="Symbol">((</a><a id="13271" href="VecMat.html#10834" class="Function">*ᵥ-zeroˡ</a> <a id="13280" href="VecMat.html#13192" class="Bound">v</a><a id="13281" class="Symbol">)</a> <a id="13283" href="VecMat.html#3812" class="InductiveConstructor Operator">∷</a> <a id="13285" href="VecMat.html#3792" class="InductiveConstructor">[]</a><a id="13287" class="Symbol">)</a> <a id="13289" class="Symbol">(</a><a id="13290" href="VecMat.html#13101" class="Function">lemma1</a> <a id="13297" href="VecMat.html#13196" class="Bound">N</a><a id="13298" class="Symbol">)</a> <a id="13300" href="Relation.Binary.Reasoning.Base.Single.html#925" class="Function Operator">⟩</a>
        <a id="13310" class="Symbol">(</a><a id="13311" href="VecMat.html#8302" class="Function">0ᵥ</a> <a id="13314" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="13316" href="VecMat.html#3098" class="InductiveConstructor">[]</a><a id="13318" class="Symbol">)</a> <a id="13320" href="VecMat.html#8619" class="Function Operator">+ₘ</a> <a id="13323" class="Symbol">(</a><a id="13324" href="VecMat.html#8302" class="Function">0ᵥ</a> <a id="13327" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="13329" href="VecMat.html#3098" class="InductiveConstructor">[]</a><a id="13331" class="Symbol">)</a>  <a id="13334" href="Relation.Binary.Reasoning.Base.Single.html#925" class="Function Operator">≈⟨</a> <a id="13337" href="VecMat.html#10957" class="Function">+ₘ-identityˡ</a> <a id="13350" href="VecMat.html#8571" class="Function">0ₘ</a> <a id="13353" href="Relation.Binary.Reasoning.Base.Single.html#925" class="Function Operator">⟩</a>
        <a id="13363" href="VecMat.html#8302" class="Function">0ᵥ</a> <a id="13366" href="VecMat.html#3118" class="InductiveConstructor Operator">∷</a> <a id="13368" href="VecMat.html#3098" class="InductiveConstructor">[]</a>  <a id="13372" href="Relation.Binary.Reasoning.Base.Single.html#1295" class="Function Operator">∎</a>
</pre>
<p>Okay, we did it, but it’s a bit of a mess. If you look at the proof, you notice that a lot of it is about getting round the fact that, for an <code>m × n</code> matrix, we only have indirect access to the <code>n</code> dimension, the columns. The <code>left/rest</code> function is the worst offender for this. It says we want access to a column of a matrix, but the inductive structure only gives us access to the rows. So we have to pick off the first coefficient in each row, and call that a column.</p>
<p>Ultimately, this means that we should be caring more about the inductive structure of the <em>dimensions</em>, rather than any inductive structure on matrices themselves. Dimensions always appear alone, so doing induction over them is always easy, whereas matrices have two dimensions. So, to stop doing induction on matrices, let’s make them not inductive data structures.</p>
<h2 id="using-what-we-learnt">Using what we learnt</h2>
<!--
<pre class="Agda"><a id="14275" class="Keyword">module</a> <a id="Right"></a><a id="14282" href="VecMat.html#14282" class="Module">Right</a> <a id="14288" class="Keyword">where</a>
</pre>-->
<p>How can we avoid prioritising one dimension of a matrix over the other? The only way of doing this I can think of is by defining vectors and matrices as <em>functions from positions to values</em>. Vectors and matrices are now no longer inductive structures, but rather functions, and our primary way of defining and using them is via <em>index notation</em>. Let’s do it.</p>
<pre class="Agda">  <a id="Right.Vec"></a><a id="14673" href="VecMat.html#14673" class="Function">Vec</a> <a id="14677" class="Symbol">:</a> <a id="14679" class="Symbol">(</a><a id="14680" href="VecMat.html#14680" class="Bound">A</a> <a id="14682" class="Symbol">:</a> <a id="14684" class="PrimitiveType">Set</a> <a id="14688" href="VecMat.html#2624" class="Generalizable">a</a><a id="14689" class="Symbol">)</a> <a id="14691" class="Symbol">(</a><a id="14692" href="VecMat.html#14692" class="Bound">n</a> <a id="14694" class="Symbol">:</a> <a id="14696" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a><a id="14697" class="Symbol">)</a> <a id="14699" class="Symbol">→</a> <a id="14701" class="PrimitiveType">Set</a> <a id="14705" href="VecMat.html#2624" class="Generalizable">a</a>
  <a id="14709" href="VecMat.html#14673" class="Function">Vec</a> <a id="14713" href="VecMat.html#14713" class="Bound">A</a> <a id="14715" href="VecMat.html#14715" class="Bound">n</a> <a id="14717" class="Symbol">=</a> <a id="14719" href="Data.Fin.Base.html#1000" class="Datatype">Fin</a> <a id="14723" href="VecMat.html#14715" class="Bound">n</a> <a id="14725" class="Symbol">→</a> <a id="14727" href="VecMat.html#14713" class="Bound">A</a>

  <a id="Right.Mat"></a><a id="14732" href="VecMat.html#14732" class="Function">Mat</a> <a id="14736" class="Symbol">:</a> <a id="14738" class="Symbol">(</a><a id="14739" href="VecMat.html#14739" class="Bound">A</a> <a id="14741" class="Symbol">:</a> <a id="14743" class="PrimitiveType">Set</a> <a id="14747" href="VecMat.html#2624" class="Generalizable">a</a><a id="14748" class="Symbol">)</a> <a id="14750" class="Symbol">(</a><a id="14751" href="VecMat.html#14751" class="Bound">m</a> <a id="14753" href="VecMat.html#14753" class="Bound">n</a> <a id="14755" class="Symbol">:</a> <a id="14757" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a><a id="14758" class="Symbol">)</a> <a id="14760" class="Symbol">→</a> <a id="14762" class="PrimitiveType">Set</a> <a id="14766" href="VecMat.html#2624" class="Generalizable">a</a>
  <a id="14770" href="VecMat.html#14732" class="Function">Mat</a> <a id="14774" href="VecMat.html#14774" class="Bound">A</a> <a id="14776" href="VecMat.html#14776" class="Bound">m</a> <a id="14778" href="VecMat.html#14778" class="Bound">n</a> <a id="14780" class="Symbol">=</a> <a id="14782" href="VecMat.html#14673" class="Function">Vec</a> <a id="14786" class="Symbol">(</a><a id="14787" href="VecMat.html#14673" class="Function">Vec</a> <a id="14791" href="VecMat.html#14774" class="Bound">A</a> <a id="14793" href="VecMat.html#14778" class="Bound">n</a><a id="14794" class="Symbol">)</a> <a id="14796" href="VecMat.html#14776" class="Bound">m</a>
    <a id="14802" class="Comment">-- equivalently, Fin m → Fin n → A</a>
</pre>
<p>This time, defining our own equivalence is even more critical. Even if the coefficients are up to propositional equality, standard Agda functions don’t support extensionality for propositional equality, so we’d have trouble proving anything.</p>
<pre class="Agda">  <a id="Right.Pw"></a><a id="15095" href="VecMat.html#15095" class="Function">Pw</a> <a id="15098" class="Symbol">:</a> <a id="15100" href="Relation.Binary.Core.html#955" class="Function">REL</a> <a id="15104" href="VecMat.html#2651" class="Generalizable">A</a> <a id="15106" href="VecMat.html#2663" class="Generalizable">B</a> <a id="15108" href="VecMat.html#2639" class="Generalizable">ℓ</a> <a id="15110" class="Symbol">→</a> <a id="15112" href="Relation.Binary.Core.html#955" class="Function">REL</a> <a id="15116" class="Symbol">(</a><a id="15117" href="VecMat.html#14673" class="Function">Vec</a> <a id="15121" href="VecMat.html#2651" class="Generalizable">A</a> <a id="15123" href="VecMat.html#2731" class="Generalizable">n</a><a id="15124" class="Symbol">)</a> <a id="15126" class="Symbol">(</a><a id="15127" href="VecMat.html#14673" class="Function">Vec</a> <a id="15131" href="VecMat.html#2663" class="Generalizable">B</a> <a id="15133" href="VecMat.html#2731" class="Generalizable">n</a><a id="15134" class="Symbol">)</a> <a id="15136" href="VecMat.html#2639" class="Generalizable">ℓ</a>
  <a id="15140" href="VecMat.html#15095" class="Function">Pw</a> <a id="15143" href="VecMat.html#15143" class="Bound">R</a> <a id="15145" href="VecMat.html#15145" class="Bound">u</a> <a id="15147" href="VecMat.html#15147" class="Bound">v</a> <a id="15149" class="Symbol">=</a> <a id="15151" class="Symbol">∀</a> <a id="15153" href="VecMat.html#15153" class="Bound">i</a> <a id="15155" class="Symbol">→</a> <a id="15157" href="VecMat.html#15143" class="Bound">R</a> <a id="15159" class="Symbol">(</a><a id="15160" href="VecMat.html#15145" class="Bound">u</a> <a id="15162" href="VecMat.html#15153" class="Bound">i</a><a id="15163" class="Symbol">)</a> <a id="15165" class="Symbol">(</a><a id="15166" href="VecMat.html#15147" class="Bound">v</a> <a id="15168" href="VecMat.html#15153" class="Bound">i</a><a id="15169" class="Symbol">)</a>
</pre>
<!--
<pre class="Agda">  <a id="Right.Pw-setoid"></a><a id="15191" href="VecMat.html#15191" class="Function">Pw-setoid</a> <a id="15201" class="Symbol">:</a> <a id="15203" href="Relation.Binary.html#1970" class="Record">Setoid</a> <a id="15210" href="VecMat.html#2634" class="Generalizable">c</a> <a id="15212" href="VecMat.html#2639" class="Generalizable">ℓ</a> <a id="15214" class="Symbol">→</a> <a id="15216" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a> <a id="15218" class="Symbol">→</a> <a id="15220" href="Relation.Binary.html#1970" class="Record">Setoid</a> <a id="15227" href="VecMat.html#2634" class="Generalizable">c</a> <a id="15229" href="VecMat.html#2639" class="Generalizable">ℓ</a>
  <a id="15233" href="VecMat.html#15191" class="Function">Pw-setoid</a> <a id="15243" href="VecMat.html#15243" class="Bound">S</a> <a id="15245" href="VecMat.html#15245" class="Bound">n</a> <a id="15247" class="Symbol">=</a> <a id="15249" class="Keyword">record</a>
    <a id="15260" class="Symbol">{</a> <a id="15262" href="Relation.Binary.html#2033" class="Field">Carrier</a> <a id="15270" class="Symbol">=</a> <a id="15272" href="VecMat.html#14673" class="Function">Vec</a> <a id="15276" href="Relation.Binary.html#2033" class="Function">Carrier</a> <a id="15284" href="VecMat.html#15245" class="Bound">n</a>
    <a id="15290" class="Symbol">;</a> <a id="15292" href="Relation.Binary.html#2059" class="Field Operator">_≈_</a> <a id="15296" class="Symbol">=</a> <a id="15298" href="VecMat.html#15095" class="Function">Pw</a> <a id="15301" href="Relation.Binary.html#2059" class="Function Operator">_≈_</a>
    <a id="15309" class="Symbol">;</a> <a id="15311" href="Relation.Binary.html#2093" class="Field">isEquivalence</a> <a id="15325" class="Symbol">=</a> <a id="15327" class="Keyword">record</a>
      <a id="15340" class="Symbol">{</a> <a id="15342" href="Relation.Binary.Core.html#7020" class="Field">refl</a> <a id="15347" class="Symbol">=</a> <a id="15349" class="Symbol">λ</a> <a id="15351" href="VecMat.html#15351" class="Bound">i</a> <a id="15353" class="Symbol">→</a> <a id="15355" href="Relation.Binary.Core.html#7020" class="Function">refl</a>
      <a id="15366" class="Symbol">;</a> <a id="15368" href="Relation.Binary.Core.html#7046" class="Field">sym</a> <a id="15372" class="Symbol">=</a> <a id="15374" class="Symbol">λ</a> <a id="15376" href="VecMat.html#15376" class="Bound">xy</a> <a id="15379" href="VecMat.html#15379" class="Bound">i</a> <a id="15381" class="Symbol">→</a> <a id="15383" href="Relation.Binary.Core.html#7046" class="Function">sym</a> <a id="15387" class="Symbol">(</a><a id="15388" href="VecMat.html#15376" class="Bound">xy</a> <a id="15391" href="VecMat.html#15379" class="Bound">i</a><a id="15392" class="Symbol">)</a>
      <a id="15400" class="Symbol">;</a> <a id="15402" href="Relation.Binary.Core.html#7072" class="Field">trans</a> <a id="15408" class="Symbol">=</a> <a id="15410" class="Symbol">λ</a> <a id="15412" href="VecMat.html#15412" class="Bound">xy</a> <a id="15415" href="VecMat.html#15415" class="Bound">yz</a> <a id="15418" href="VecMat.html#15418" class="Bound">i</a> <a id="15420" class="Symbol">→</a> <a id="15422" href="Relation.Binary.Core.html#7072" class="Function">trans</a> <a id="15428" class="Symbol">(</a><a id="15429" href="VecMat.html#15412" class="Bound">xy</a> <a id="15432" href="VecMat.html#15418" class="Bound">i</a><a id="15433" class="Symbol">)</a> <a id="15435" class="Symbol">(</a><a id="15436" href="VecMat.html#15415" class="Bound">yz</a> <a id="15439" href="VecMat.html#15418" class="Bound">i</a><a id="15440" class="Symbol">)</a>
      <a id="15448" class="Symbol">}</a>
    <a id="15454" class="Symbol">}</a> <a id="15456" class="Keyword">where</a> <a id="15462" class="Keyword">open</a> <a id="15467" href="Relation.Binary.html#1970" class="Module">Setoid</a> <a id="15474" href="VecMat.html#15243" class="Bound">S</a>
</pre>-->
<p>Next, we can think about matrix operations.</p>
<pre class="Agda">  <a id="15540" class="Keyword">module</a> <a id="WithSemiring"></a><a id="15547" href="VecMat.html#15547" class="Module">WithSemiring</a> <a id="15560" class="Symbol">(</a><a id="15561" href="VecMat.html#15561" class="Bound">R</a> <a id="15563" class="Symbol">:</a> <a id="15565" href="Algebra.html#12064" class="Record">Semiring</a> <a id="15574" href="VecMat.html#2634" class="Generalizable">c</a> <a id="15576" href="VecMat.html#2639" class="Generalizable">ℓ</a><a id="15577" class="Symbol">)</a> <a id="15579" class="Keyword">where</a>
    <a id="15589" class="Keyword">open</a> <a id="15594" href="Algebra.html#12064" class="Module">Semiring</a> <a id="15603" href="VecMat.html#15561" class="Bound">R</a> <a id="15605" class="Keyword">hiding</a> <a id="15612" class="Symbol">(</a>zero<a id="15617" class="Symbol">)</a>
</pre>
<pre class="Agda">    <a id="15636" class="Keyword">infix</a> <a id="15642" class="Number">4</a> <a id="15644" href="VecMat.html#15658" class="Function Operator">_≈ᵥ_</a> <a id="15649" href="VecMat.html#15709" class="Function Operator">_≈ₘ_</a>
    <a id="Right.WithSemiring._≈ᵥ_"></a><a id="15658" href="VecMat.html#15658" class="Function Operator">_≈ᵥ_</a> <a id="15663" class="Symbol">:</a> <a id="15665" href="Relation.Binary.Core.html#1071" class="Function">Rel</a> <a id="15669" class="Symbol">(</a><a id="15670" href="VecMat.html#14673" class="Function">Vec</a> <a id="15674" href="Algebra.html#12160" class="Field">Carrier</a> <a id="15682" href="VecMat.html#2731" class="Generalizable">n</a><a id="15683" class="Symbol">)</a> <a id="15685" href="VecMat.html#15576" class="Bound">ℓ</a>
    <a id="15691" href="VecMat.html#15658" class="Function Operator">_≈ᵥ_</a> <a id="15696" class="Symbol">=</a> <a id="15698" href="VecMat.html#15095" class="Function">Pw</a> <a id="15701" href="Algebra.html#12183" class="Field Operator">_≈_</a>
    <a id="Right.WithSemiring._≈ₘ_"></a><a id="15709" href="VecMat.html#15709" class="Function Operator">_≈ₘ_</a> <a id="15714" class="Symbol">:</a> <a id="15716" href="Relation.Binary.Core.html#1071" class="Function">Rel</a> <a id="15720" class="Symbol">(</a><a id="15721" href="VecMat.html#14732" class="Function">Mat</a> <a id="15725" href="Algebra.html#12160" class="Field">Carrier</a> <a id="15733" href="VecMat.html#2729" class="Generalizable">m</a> <a id="15735" href="VecMat.html#2731" class="Generalizable">n</a><a id="15736" class="Symbol">)</a> <a id="15738" href="VecMat.html#15576" class="Bound">ℓ</a>
    <a id="15744" href="VecMat.html#15709" class="Function Operator">_≈ₘ_</a> <a id="15749" class="Symbol">=</a> <a id="15751" href="VecMat.html#15095" class="Function">Pw</a> <a id="15754" href="VecMat.html#15658" class="Function Operator">_≈ᵥ_</a>
</pre>
<p>The additive structure is particularly easy. Everything is pointwise in a way that even Agda can see, so the lemmas are easy too.</p>
<pre class="Agda">    <a id="Right.WithSemiring.0ₘ"></a><a id="15907" href="VecMat.html#15907" class="Function">0ₘ</a> <a id="15910" class="Symbol">:</a> <a id="15912" href="VecMat.html#14732" class="Function">Mat</a> <a id="15916" href="Algebra.html#12160" class="Field">Carrier</a> <a id="15924" href="VecMat.html#2729" class="Generalizable">m</a> <a id="15926" href="VecMat.html#2731" class="Generalizable">n</a>
    <a id="15932" href="VecMat.html#15907" class="Function">0ₘ</a> <a id="15935" class="Symbol">_</a> <a id="15937" class="Symbol">_</a> <a id="15939" class="Symbol">=</a> <a id="15941" href="Algebra.html#12272" class="Field">0#</a>

    <a id="Right.WithSemiring._+ₘ_"></a><a id="15949" href="VecMat.html#15949" class="Function Operator">_+ₘ_</a> <a id="15954" class="Symbol">:</a> <a id="15956" class="Symbol">(</a><a id="15957" href="VecMat.html#15957" class="Bound">M</a> <a id="15959" href="VecMat.html#15959" class="Bound">N</a> <a id="15961" class="Symbol">:</a> <a id="15963" href="VecMat.html#14732" class="Function">Mat</a> <a id="15967" href="Algebra.html#12160" class="Field">Carrier</a> <a id="15975" href="VecMat.html#2729" class="Generalizable">m</a> <a id="15977" href="VecMat.html#2731" class="Generalizable">n</a><a id="15978" class="Symbol">)</a> <a id="15980" class="Symbol">→</a> <a id="15982" href="VecMat.html#14732" class="Function">Mat</a> <a id="15986" href="Algebra.html#12160" class="Field">Carrier</a> <a id="15994" href="VecMat.html#2729" class="Generalizable">m</a> <a id="15996" href="VecMat.html#2731" class="Generalizable">n</a>
    <a id="16002" class="Symbol">(</a><a id="16003" href="VecMat.html#16003" class="Bound">M</a> <a id="16005" href="VecMat.html#15949" class="Function Operator">+ₘ</a> <a id="16008" href="VecMat.html#16008" class="Bound">N</a><a id="16009" class="Symbol">)</a> <a id="16011" href="VecMat.html#16011" class="Bound">i</a> <a id="16013" href="VecMat.html#16013" class="Bound">j</a> <a id="16015" class="Symbol">=</a> <a id="16017" href="VecMat.html#16003" class="Bound">M</a> <a id="16019" href="VecMat.html#16011" class="Bound">i</a> <a id="16021" href="VecMat.html#16013" class="Bound">j</a> <a id="16023" href="Algebra.html#12214" class="Field Operator">+</a> <a id="16025" href="VecMat.html#16008" class="Bound">N</a> <a id="16027" href="VecMat.html#16011" class="Bound">i</a> <a id="16029" href="VecMat.html#16013" class="Bound">j</a>

    <a id="16036" class="Comment">-- An example property:</a>
    <a id="Right.WithSemiring.+ₘ-identityˡ"></a><a id="16064" href="VecMat.html#16064" class="Function">+ₘ-identityˡ</a> <a id="16077" class="Symbol">:</a> <a id="16079" class="Symbol">(</a><a id="16080" href="VecMat.html#16080" class="Bound">M</a> <a id="16082" class="Symbol">:</a> <a id="16084" href="VecMat.html#14732" class="Function">Mat</a> <a id="16088" href="Algebra.html#12160" class="Field">Carrier</a> <a id="16096" href="VecMat.html#2729" class="Generalizable">m</a> <a id="16098" href="VecMat.html#2731" class="Generalizable">n</a><a id="16099" class="Symbol">)</a> <a id="16101" class="Symbol">→</a> <a id="16103" href="VecMat.html#15907" class="Function">0ₘ</a> <a id="16106" href="VecMat.html#15949" class="Function Operator">+ₘ</a> <a id="16109" href="VecMat.html#16080" class="Bound">M</a> <a id="16111" href="VecMat.html#15709" class="Function Operator">≈ₘ</a> <a id="16114" href="VecMat.html#16080" class="Bound">M</a>
    <a id="16120" href="VecMat.html#16064" class="Function">+ₘ-identityˡ</a> <a id="16133" href="VecMat.html#16133" class="Bound">M</a> <a id="16135" href="VecMat.html#16135" class="Bound">i</a> <a id="16137" href="VecMat.html#16137" class="Bound">j</a> <a id="16139" class="Symbol">=</a> <a id="16141" href="Algebra.Structures.html#2610" class="Function">+-identityˡ</a> <a id="16153" class="Symbol">(</a><a id="16154" href="VecMat.html#16133" class="Bound">M</a> <a id="16156" href="VecMat.html#16135" class="Bound">i</a> <a id="16158" href="VecMat.html#16137" class="Bound">j</a><a id="16159" class="Symbol">)</a>
</pre>
<p>The multiplicative structure still requires some thought. In particular, there are some careful choices to be made about the identity matrix, which I will explain when we prove things about it.</p>
<pre class="Agda">    <a id="Right.WithSemiring._==_"></a><a id="16373" href="VecMat.html#16373" class="Function Operator">_==_</a> <a id="16378" class="Symbol">:</a> <a id="16380" class="Symbol">(</a><a id="16381" href="VecMat.html#16381" class="Bound">i</a> <a id="16383" href="VecMat.html#16383" class="Bound">j</a> <a id="16385" class="Symbol">:</a> <a id="16387" href="Data.Fin.Base.html#1000" class="Datatype">Fin</a> <a id="16391" href="VecMat.html#2731" class="Generalizable">n</a><a id="16392" class="Symbol">)</a> <a id="16394" class="Symbol">→</a> <a id="16396" href="Agda.Builtin.Bool.html#135" class="Datatype">Bool</a>
    <a id="16405" href="Data.Fin.Base.html#1022" class="InductiveConstructor">zero</a> <a id="16410" href="VecMat.html#16373" class="Function Operator">==</a> <a id="16413" href="Data.Fin.Base.html#1022" class="InductiveConstructor">zero</a> <a id="16418" class="Symbol">=</a> <a id="16420" href="Agda.Builtin.Bool.html#160" class="InductiveConstructor">true</a>
    <a id="16429" href="Data.Fin.Base.html#1022" class="InductiveConstructor">zero</a> <a id="16434" href="VecMat.html#16373" class="Function Operator">==</a> <a id="16437" href="Data.Fin.Base.html#1053" class="InductiveConstructor">suc</a> <a id="16441" href="VecMat.html#16441" class="Bound">j</a> <a id="16443" class="Symbol">=</a> <a id="16445" href="Agda.Builtin.Bool.html#154" class="InductiveConstructor">false</a>
    <a id="16455" href="Data.Fin.Base.html#1053" class="InductiveConstructor">suc</a> <a id="16459" href="VecMat.html#16459" class="Bound">i</a> <a id="16461" href="VecMat.html#16373" class="Function Operator">==</a> <a id="16464" href="Data.Fin.Base.html#1022" class="InductiveConstructor">zero</a> <a id="16469" class="Symbol">=</a> <a id="16471" href="Agda.Builtin.Bool.html#154" class="InductiveConstructor">false</a>
    <a id="16481" href="Data.Fin.Base.html#1053" class="InductiveConstructor">suc</a> <a id="16485" href="VecMat.html#16485" class="Bound">i</a> <a id="16487" href="VecMat.html#16373" class="Function Operator">==</a> <a id="16490" href="Data.Fin.Base.html#1053" class="InductiveConstructor">suc</a> <a id="16494" href="VecMat.html#16494" class="Bound">j</a> <a id="16496" class="Symbol">=</a> <a id="16498" href="VecMat.html#16485" class="Bound">i</a> <a id="16500" href="VecMat.html#16373" class="Function Operator">==</a> <a id="16503" href="VecMat.html#16494" class="Bound">j</a>

    <a id="Right.WithSemiring.1ₘ"></a><a id="16510" href="VecMat.html#16510" class="Function">1ₘ</a> <a id="16513" class="Symbol">:</a> <a id="16515" href="VecMat.html#14732" class="Function">Mat</a> <a id="16519" href="Algebra.html#12160" class="Field">Carrier</a> <a id="16527" href="VecMat.html#2729" class="Generalizable">m</a> <a id="16529" href="VecMat.html#2729" class="Generalizable">m</a>
    <a id="16535" href="VecMat.html#16510" class="Function">1ₘ</a> <a id="16538" href="VecMat.html#16538" class="Bound">i</a> <a id="16540" href="VecMat.html#16540" class="Bound">j</a> <a id="16542" class="Symbol">=</a> <a id="16544" href="Data.Bool.Base.html#1312" class="Function Operator">if</a> <a id="16547" href="VecMat.html#16538" class="Bound">i</a> <a id="16549" href="VecMat.html#16373" class="Function Operator">==</a> <a id="16552" href="VecMat.html#16540" class="Bound">j</a> <a id="16554" href="Data.Bool.Base.html#1312" class="Function Operator">then</a> <a id="16559" href="Algebra.html#12297" class="Field">1#</a> <a id="16562" href="Data.Bool.Base.html#1312" class="Function Operator">else</a> <a id="16567" href="Algebra.html#12272" class="Field">0#</a>

    <a id="Right.WithSemiring.sum"></a><a id="16575" href="VecMat.html#16575" class="Function">sum</a> <a id="16579" class="Symbol">:</a> <a id="16581" href="VecMat.html#14673" class="Function">Vec</a> <a id="16585" href="Algebra.html#12160" class="Field">Carrier</a> <a id="16593" href="VecMat.html#2731" class="Generalizable">n</a> <a id="16595" class="Symbol">→</a> <a id="16597" href="Algebra.html#12160" class="Field">Carrier</a>
    <a id="16609" href="VecMat.html#16575" class="Function">sum</a> <a id="16613" class="Symbol">{</a><a id="16614" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a><a id="16618" class="Symbol">}</a> <a id="16620" href="VecMat.html#16620" class="Bound">v</a> <a id="16622" class="Symbol">=</a> <a id="16624" href="Algebra.html#12272" class="Field">0#</a>
    <a id="16631" href="VecMat.html#16575" class="Function">sum</a> <a id="16635" class="Symbol">{</a><a id="16636" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="16640" href="VecMat.html#16640" class="Bound">n</a><a id="16641" class="Symbol">}</a> <a id="16643" href="VecMat.html#16643" class="Bound">v</a> <a id="16645" class="Symbol">=</a> <a id="16647" href="VecMat.html#16643" class="Bound">v</a> <a id="16649" href="Data.Fin.Base.html#1022" class="InductiveConstructor">zero</a> <a id="16654" href="Algebra.html#12214" class="Field Operator">+</a> <a id="16656" href="VecMat.html#16575" class="Function">sum</a> <a id="16660" class="Symbol">{</a><a id="16661" href="VecMat.html#16640" class="Bound">n</a><a id="16662" class="Symbol">}</a> <a id="16664" class="Symbol">(</a><a id="16665" href="VecMat.html#16643" class="Bound">v</a> <a id="16667" href="Function.html#1099" class="Function Operator">∘</a> <a id="16669" href="Data.Fin.Base.html#1053" class="InductiveConstructor">suc</a><a id="16672" class="Symbol">)</a>

    <a id="Right.WithSemiring._*ₘ_"></a><a id="16679" href="VecMat.html#16679" class="Function Operator">_*ₘ_</a> <a id="16684" class="Symbol">:</a> <a id="16686" href="VecMat.html#14732" class="Function">Mat</a> <a id="16690" href="Algebra.html#12160" class="Field">Carrier</a> <a id="16698" href="VecMat.html#2729" class="Generalizable">m</a> <a id="16700" href="VecMat.html#2731" class="Generalizable">n</a> <a id="16702" class="Symbol">→</a> <a id="16704" href="VecMat.html#14732" class="Function">Mat</a> <a id="16708" href="Algebra.html#12160" class="Field">Carrier</a> <a id="16716" href="VecMat.html#2731" class="Generalizable">n</a> <a id="16718" href="VecMat.html#2733" class="Generalizable">o</a> <a id="16720" class="Symbol">→</a> <a id="16722" href="VecMat.html#14732" class="Function">Mat</a> <a id="16726" href="Algebra.html#12160" class="Field">Carrier</a> <a id="16734" href="VecMat.html#2729" class="Generalizable">m</a> <a id="16736" href="VecMat.html#2733" class="Generalizable">o</a>
    <a id="16742" class="Symbol">(</a><a id="16743" href="VecMat.html#16743" class="Bound">M</a> <a id="16745" href="VecMat.html#16679" class="Function Operator">*ₘ</a> <a id="16748" href="VecMat.html#16748" class="Bound">N</a><a id="16749" class="Symbol">)</a> <a id="16751" href="VecMat.html#16751" class="Bound">i</a> <a id="16753" href="VecMat.html#16753" class="Bound">k</a> <a id="16755" class="Symbol">=</a> <a id="16757" href="VecMat.html#16575" class="Function">sum</a> <a id="16761" class="Symbol">\</a> <a id="16763" href="VecMat.html#16763" class="Bound">j</a> <a id="16765" class="Symbol">→</a> <a id="16767" href="VecMat.html#16743" class="Bound">M</a> <a id="16769" href="VecMat.html#16751" class="Bound">i</a> <a id="16771" href="VecMat.html#16763" class="Bound">j</a> <a id="16773" href="Algebra.html#12243" class="Field Operator">*</a> <a id="16775" href="VecMat.html#16748" class="Bound">N</a> <a id="16777" href="VecMat.html#16763" class="Bound">j</a> <a id="16779" href="VecMat.html#16753" class="Bound">k</a>
</pre>
<p>These definitions should better resemble standard mathematical practice. Rather than our input-driven, parallel definition of <code>_*ₘ_</code> from before, we have an output-driven definition in terms of lots of little <code>sum</code>s (mathematical Σ). <code>1ₘ</code> has gone from the rather alien functional programming construction to the <a href="https://en.wikipedia.org/wiki/Kronecker_delta">Kronecker δ</a>.</p>
<p>Now, how about our test case of proving properties about multiplication?</p>
<!--
<pre class="Agda">    <a id="Right.WithSemiring.sum-cong"></a><a id="17253" href="VecMat.html#17253" class="Function">sum-cong</a> <a id="17262" class="Symbol">:</a> <a id="17264" class="Symbol">{</a><a id="17265" href="VecMat.html#17265" class="Bound">u</a> <a id="17267" href="VecMat.html#17267" class="Bound">v</a> <a id="17269" class="Symbol">:</a> <a id="17271" href="VecMat.html#14673" class="Function">Vec</a> <a id="17275" class="Symbol">_</a> <a id="17277" href="VecMat.html#2731" class="Generalizable">n</a><a id="17278" class="Symbol">}</a> <a id="17280" class="Symbol">→</a> <a id="17282" href="VecMat.html#17265" class="Bound">u</a> <a id="17284" href="VecMat.html#15658" class="Function Operator">≈ᵥ</a> <a id="17287" href="VecMat.html#17267" class="Bound">v</a> <a id="17289" class="Symbol">→</a> <a id="17291" href="VecMat.html#16575" class="Function">sum</a> <a id="17295" href="VecMat.html#17265" class="Bound">u</a> <a id="17297" href="Algebra.html#12183" class="Field Operator">≈</a> <a id="17299" href="VecMat.html#16575" class="Function">sum</a> <a id="17303" href="VecMat.html#17267" class="Bound">v</a>
    <a id="17309" href="VecMat.html#17253" class="Function">sum-cong</a> <a id="17318" class="Symbol">{</a><a id="17319" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a><a id="17323" class="Symbol">}</a> <a id="17325" href="VecMat.html#17325" class="Bound">q</a> <a id="17327" class="Symbol">=</a> <a id="17329" href="Relation.Binary.Core.html#7020" class="Function">refl</a>
    <a id="17338" href="VecMat.html#17253" class="Function">sum-cong</a> <a id="17347" class="Symbol">{</a><a id="17348" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="17352" href="VecMat.html#17352" class="Bound">n</a><a id="17353" class="Symbol">}</a> <a id="17355" href="VecMat.html#17355" class="Bound">q</a> <a id="17357" class="Symbol">=</a> <a id="17359" href="Algebra.Structures.html#1078" class="Function">+-cong</a> <a id="17366" class="Symbol">(</a><a id="17367" href="VecMat.html#17355" class="Bound">q</a> <a id="17369" href="Data.Fin.Base.html#1022" class="InductiveConstructor">zero</a><a id="17373" class="Symbol">)</a> <a id="17375" class="Symbol">(</a><a id="17376" href="VecMat.html#17253" class="Function">sum-cong</a> <a id="17385" class="Symbol">{</a><a id="17386" href="VecMat.html#17352" class="Bound">n</a><a id="17387" class="Symbol">}</a> <a id="17389" class="Symbol">(</a><a id="17390" href="VecMat.html#17355" class="Bound">q</a> <a id="17392" href="Function.html#1099" class="Function Operator">∘</a> <a id="17394" href="Data.Fin.Base.html#1053" class="InductiveConstructor">suc</a><a id="17397" class="Symbol">))</a>

    <a id="Right.WithSemiring.*-sum"></a><a id="17405" href="VecMat.html#17405" class="Function">*-sum</a> <a id="17411" class="Symbol">:</a> <a id="17413" class="Symbol">∀</a> <a id="17415" href="VecMat.html#17415" class="Bound">x</a> <a id="17417" class="Symbol">(</a><a id="17418" href="VecMat.html#17418" class="Bound">u</a> <a id="17420" class="Symbol">:</a> <a id="17422" href="VecMat.html#14673" class="Function">Vec</a> <a id="17426" class="Symbol">_</a> <a id="17428" href="VecMat.html#2731" class="Generalizable">n</a><a id="17429" class="Symbol">)</a> <a id="17431" class="Symbol">→</a> <a id="17433" class="Symbol">(</a><a id="17434" href="VecMat.html#16575" class="Function">sum</a> <a id="17438" class="Symbol">\</a> <a id="17440" href="VecMat.html#17440" class="Bound">i</a> <a id="17442" class="Symbol">→</a> <a id="17444" href="VecMat.html#17415" class="Bound">x</a> <a id="17446" href="Algebra.html#12243" class="Field Operator">*</a> <a id="17448" href="VecMat.html#17418" class="Bound">u</a> <a id="17450" href="VecMat.html#17440" class="Bound">i</a><a id="17451" class="Symbol">)</a> <a id="17453" href="Algebra.html#12183" class="Field Operator">≈</a> <a id="17455" href="VecMat.html#17415" class="Bound">x</a> <a id="17457" href="Algebra.html#12243" class="Field Operator">*</a> <a id="17459" href="VecMat.html#16575" class="Function">sum</a> <a id="17463" href="VecMat.html#17418" class="Bound">u</a>
    <a id="17469" href="VecMat.html#17405" class="Function">*-sum</a> <a id="17475" class="Symbol">{</a><a id="17476" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a><a id="17480" class="Symbol">}</a> <a id="17482" href="VecMat.html#17482" class="Bound">x</a> <a id="17484" href="VecMat.html#17484" class="Bound">u</a> <a id="17486" class="Symbol">=</a> <a id="17488" href="Relation.Binary.Core.html#7046" class="Function">sym</a> <a id="17492" class="Symbol">(</a><a id="17493" href="Algebra.Structures.html#8034" class="Function">zeroʳ</a> <a id="17499" href="VecMat.html#17482" class="Bound">x</a><a id="17500" class="Symbol">)</a>
    <a id="17506" href="VecMat.html#17405" class="Function">*-sum</a> <a id="17512" class="Symbol">{</a><a id="17513" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="17517" href="VecMat.html#17517" class="Bound">n</a><a id="17518" class="Symbol">}</a> <a id="17520" href="VecMat.html#17520" class="Bound">x</a> <a id="17522" href="VecMat.html#17522" class="Bound">u</a> <a id="17524" class="Symbol">=</a>
      <a id="17532" href="Relation.Binary.Core.html#7072" class="Function">trans</a> <a id="17538" class="Symbol">(</a><a id="17539" href="Algebra.Structures.html#1078" class="Function">+-cong</a> <a id="17546" href="Relation.Binary.Core.html#7020" class="Function">refl</a> <a id="17551" class="Symbol">(</a><a id="17552" href="VecMat.html#17405" class="Function">*-sum</a> <a id="17558" class="Symbol">{</a><a id="17559" href="VecMat.html#17517" class="Bound">n</a><a id="17560" class="Symbol">}</a> <a id="17562" href="VecMat.html#17520" class="Bound">x</a> <a id="17564" class="Symbol">(</a><a id="17565" href="VecMat.html#17522" class="Bound">u</a> <a id="17567" href="Function.html#1099" class="Function Operator">∘</a> <a id="17569" href="Data.Fin.Base.html#1053" class="InductiveConstructor">suc</a> <a id="17573" class="Symbol">)))</a>
            <a id="17589" class="Symbol">(</a><a id="17590" href="Relation.Binary.Core.html#7046" class="Function">sym</a> <a id="17594" class="Symbol">(</a><a id="17595" href="Algebra.Structures.html#9227" class="Function">distribˡ</a> <a id="17604" href="VecMat.html#17520" class="Bound">x</a> <a id="17606" class="Symbol">(</a><a id="17607" href="VecMat.html#17522" class="Bound">u</a> <a id="17609" href="Data.Fin.Base.html#1022" class="InductiveConstructor">zero</a><a id="17613" class="Symbol">)</a> <a id="17615" class="Symbol">(</a><a id="17616" href="VecMat.html#16575" class="Function">sum</a> <a id="17620" class="Symbol">(</a><a id="17621" href="VecMat.html#17522" class="Bound">u</a> <a id="17623" href="Function.html#1099" class="Function Operator">∘</a> <a id="17625" href="Data.Fin.Base.html#1053" class="InductiveConstructor">suc</a><a id="17628" class="Symbol">))))</a>
</pre>-->
<pre class="Agda">    <a id="Right.WithSemiring.*ₘ-identityˡ"></a><a id="17654" href="VecMat.html#17654" class="Function">*ₘ-identityˡ</a> <a id="17667" class="Symbol">:</a> <a id="17669" class="Symbol">(</a><a id="17670" href="VecMat.html#17670" class="Bound">M</a> <a id="17672" class="Symbol">:</a> <a id="17674" href="VecMat.html#14732" class="Function">Mat</a> <a id="17678" href="Algebra.html#12160" class="Field">Carrier</a> <a id="17686" href="VecMat.html#2729" class="Generalizable">m</a> <a id="17688" href="VecMat.html#2731" class="Generalizable">n</a><a id="17689" class="Symbol">)</a> <a id="17691" class="Symbol">→</a> <a id="17693" href="VecMat.html#16510" class="Function">1ₘ</a> <a id="17696" href="VecMat.html#16679" class="Function Operator">*ₘ</a> <a id="17699" href="VecMat.html#17670" class="Bound">M</a> <a id="17701" href="VecMat.html#15709" class="Function Operator">≈ₘ</a> <a id="17704" href="VecMat.html#17670" class="Bound">M</a>
    <a id="17710" href="VecMat.html#17654" class="Function">*ₘ-identityˡ</a> <a id="17723" class="Symbol">{</a><a id="17724" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="17728" href="VecMat.html#17728" class="Bound">m</a><a id="17729" class="Symbol">}</a> <a id="17731" class="Symbol">{</a><a id="17732" href="VecMat.html#17732" class="Bound">n</a><a id="17733" class="Symbol">}</a> <a id="17735" href="VecMat.html#17735" class="Bound">M</a> <a id="17737" href="Data.Fin.Base.html#1022" class="InductiveConstructor">zero</a> <a id="17742" href="VecMat.html#17742" class="Bound">k</a> <a id="17744" class="Symbol">=</a> <a id="17746" href="Relation.Binary.Reasoning.Base.Single.html#859" class="Function Operator">begin</a>
      <a id="17758" class="Symbol">(</a><a id="17759" href="VecMat.html#16510" class="Function">1ₘ</a> <a id="17762" href="VecMat.html#16679" class="Function Operator">*ₘ</a> <a id="17765" href="VecMat.html#17735" class="Bound">M</a><a id="17766" class="Symbol">)</a> <a id="17768" href="Data.Fin.Base.html#1022" class="InductiveConstructor">zero</a> <a id="17773" href="VecMat.html#17742" class="Bound">k</a>                                           <a id="17817" href="Relation.Binary.Reasoning.Base.Single.html#1212" class="Function Operator">≡⟨⟩</a>
      <a id="17827" href="VecMat.html#16510" class="Function">1ₘ</a> <a id="17830" class="Symbol">{</a><a id="17831" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="17835" href="VecMat.html#17728" class="Bound">m</a><a id="17836" class="Symbol">}</a> <a id="17838" href="Data.Fin.Base.html#1022" class="InductiveConstructor">zero</a> <a id="17843" href="Data.Fin.Base.html#1022" class="InductiveConstructor">zero</a> <a id="17848" href="Algebra.html#12243" class="Field Operator">*</a> <a id="17850" href="VecMat.html#17735" class="Bound">M</a> <a id="17852" href="Data.Fin.Base.html#1022" class="InductiveConstructor">zero</a> <a id="17857" href="VecMat.html#17742" class="Bound">k</a>
                    <a id="17879" href="Algebra.html#12214" class="Field Operator">+</a> <a id="17881" class="Symbol">(</a><a id="17882" href="VecMat.html#16575" class="Function">sum</a> <a id="17886" class="Symbol">\</a> <a id="17888" href="VecMat.html#17888" class="Bound">j</a> <a id="17890" class="Symbol">→</a> <a id="17892" href="VecMat.html#16510" class="Function">1ₘ</a> <a id="17895" href="Data.Fin.Base.html#1022" class="InductiveConstructor">zero</a> <a id="17900" class="Symbol">(</a><a id="17901" href="Data.Fin.Base.html#1053" class="InductiveConstructor">suc</a> <a id="17905" href="VecMat.html#17888" class="Bound">j</a><a id="17906" class="Symbol">)</a> <a id="17908" href="Algebra.html#12243" class="Field Operator">*</a> <a id="17910" href="VecMat.html#17735" class="Bound">M</a> <a id="17912" class="Symbol">(</a><a id="17913" href="Data.Fin.Base.html#1053" class="InductiveConstructor">suc</a> <a id="17917" href="VecMat.html#17888" class="Bound">j</a><a id="17918" class="Symbol">)</a> <a id="17920" href="VecMat.html#17742" class="Bound">k</a><a id="17921" class="Symbol">)</a>  <a id="17924" href="Relation.Binary.Reasoning.Base.Single.html#1212" class="Function Operator">≡⟨⟩</a>
      <a id="17934" href="Algebra.html#12297" class="Field">1#</a> <a id="17937" href="Algebra.html#12243" class="Field Operator">*</a> <a id="17939" href="VecMat.html#17735" class="Bound">M</a> <a id="17941" href="Data.Fin.Base.html#1022" class="InductiveConstructor">zero</a> <a id="17946" href="VecMat.html#17742" class="Bound">k</a> <a id="17948" href="Algebra.html#12214" class="Field Operator">+</a> <a id="17950" class="Symbol">(</a><a id="17951" href="VecMat.html#16575" class="Function">sum</a> <a id="17955" class="Symbol">\</a> <a id="17957" href="VecMat.html#17957" class="Bound">j</a> <a id="17959" class="Symbol">→</a> <a id="17961" href="Algebra.html#12272" class="Field">0#</a> <a id="17964" href="Algebra.html#12243" class="Field Operator">*</a> <a id="17966" href="VecMat.html#17735" class="Bound">M</a> <a id="17968" class="Symbol">(</a><a id="17969" href="Data.Fin.Base.html#1053" class="InductiveConstructor">suc</a> <a id="17973" href="VecMat.html#17957" class="Bound">j</a><a id="17974" class="Symbol">)</a> <a id="17976" href="VecMat.html#17742" class="Bound">k</a><a id="17977" class="Symbol">)</a>
                        <a id="18003" href="Relation.Binary.Reasoning.Base.Single.html#925" class="Function Operator">≈⟨</a> <a id="18006" href="Algebra.Structures.html#1078" class="Function">+-cong</a> <a id="18013" class="Symbol">(</a><a id="18014" href="Algebra.Structures.html#2377" class="Function">*-identityˡ</a> <a id="18026" class="Symbol">_)</a> <a id="18029" class="Symbol">(</a><a id="18030" href="VecMat.html#17405" class="Function">*-sum</a> <a id="18036" href="Algebra.html#12272" class="Field">0#</a> <a id="18039" class="Symbol">\</a> <a id="18041" href="VecMat.html#18041" class="Bound">j</a> <a id="18043" class="Symbol">→</a> <a id="18045" href="VecMat.html#17735" class="Bound">M</a> <a id="18047" class="Symbol">(</a><a id="18048" href="Data.Fin.Base.html#1053" class="InductiveConstructor">suc</a> <a id="18052" href="VecMat.html#18041" class="Bound">j</a><a id="18053" class="Symbol">)</a> <a id="18055" href="VecMat.html#17742" class="Bound">k</a><a id="18056" class="Symbol">)</a> <a id="18058" href="Relation.Binary.Reasoning.Base.Single.html#925" class="Function Operator">⟩</a>
           <a id="18071" href="VecMat.html#17735" class="Bound">M</a> <a id="18073" href="Data.Fin.Base.html#1022" class="InductiveConstructor">zero</a> <a id="18078" href="VecMat.html#17742" class="Bound">k</a> <a id="18080" href="Algebra.html#12214" class="Field Operator">+</a> <a id="18082" href="Algebra.html#12272" class="Field">0#</a> <a id="18085" href="Algebra.html#12243" class="Field Operator">*</a> <a id="18087" class="Symbol">(</a><a id="18088" href="VecMat.html#16575" class="Function">sum</a> <a id="18092" class="Symbol">\</a> <a id="18094" href="VecMat.html#18094" class="Bound">j</a> <a id="18096" class="Symbol">→</a> <a id="18098" href="VecMat.html#17735" class="Bound">M</a> <a id="18100" class="Symbol">(</a><a id="18101" href="Data.Fin.Base.html#1053" class="InductiveConstructor">suc</a> <a id="18105" href="VecMat.html#18094" class="Bound">j</a><a id="18106" class="Symbol">)</a> <a id="18108" href="VecMat.html#17742" class="Bound">k</a><a id="18109" class="Symbol">)</a>    <a id="18114" href="Relation.Binary.Reasoning.Base.Single.html#925" class="Function Operator">≈⟨</a> <a id="18117" href="Algebra.Structures.html#1078" class="Function">+-cong</a> <a id="18124" href="Relation.Binary.Core.html#7020" class="Function">refl</a> <a id="18129" class="Symbol">(</a><a id="18130" href="Algebra.Structures.html#7988" class="Function">zeroˡ</a> <a id="18136" class="Symbol">_)</a> <a id="18139" href="Relation.Binary.Reasoning.Base.Single.html#925" class="Function Operator">⟩</a>
           <a id="18152" href="VecMat.html#17735" class="Bound">M</a> <a id="18154" href="Data.Fin.Base.html#1022" class="InductiveConstructor">zero</a> <a id="18159" href="VecMat.html#17742" class="Bound">k</a> <a id="18161" href="Algebra.html#12214" class="Field Operator">+</a> <a id="18163" href="Algebra.html#12272" class="Field">0#</a>                              <a id="18195" href="Relation.Binary.Reasoning.Base.Single.html#925" class="Function Operator">≈⟨</a> <a id="18198" href="Algebra.Structures.html#2715" class="Function">+-identityʳ</a> <a id="18210" class="Symbol">_</a> <a id="18212" href="Relation.Binary.Reasoning.Base.Single.html#925" class="Function Operator">⟩</a>
           <a id="18225" href="VecMat.html#17735" class="Bound">M</a> <a id="18227" href="Data.Fin.Base.html#1022" class="InductiveConstructor">zero</a> <a id="18232" href="VecMat.html#17742" class="Bound">k</a>                                   <a id="18268" href="Relation.Binary.Reasoning.Base.Single.html#1295" class="Function Operator">∎</a>
      <a id="18276" class="Keyword">where</a> <a id="18282" class="Keyword">open</a> <a id="18287" href="Relation.Binary.Reasoning.Setoid.html" class="Module">SetoidReasoning</a> <a id="18303" href="Algebra.Structures.html#1153" class="Function">setoid</a>
    <a id="18314" href="VecMat.html#17654" class="Function">*ₘ-identityˡ</a> <a id="18327" class="Symbol">{</a><a id="18328" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="18332" href="VecMat.html#18332" class="Bound">m</a><a id="18333" class="Symbol">}</a> <a id="18335" class="Symbol">{</a><a id="18336" href="VecMat.html#18336" class="Bound">n</a><a id="18337" class="Symbol">}</a> <a id="18339" href="VecMat.html#18339" class="Bound">M</a> <a id="18341" class="Symbol">(</a><a id="18342" href="Data.Fin.Base.html#1053" class="InductiveConstructor">suc</a> <a id="18346" href="VecMat.html#18346" class="Bound">i</a><a id="18347" class="Symbol">)</a> <a id="18349" href="VecMat.html#18349" class="Bound">k</a> <a id="18351" class="Symbol">=</a> <a id="18353" href="Relation.Binary.Reasoning.Base.Single.html#859" class="Function Operator">begin</a>
      <a id="18365" class="Symbol">(</a><a id="18366" href="VecMat.html#16510" class="Function">1ₘ</a> <a id="18369" href="VecMat.html#16679" class="Function Operator">*ₘ</a> <a id="18372" href="VecMat.html#18339" class="Bound">M</a><a id="18373" class="Symbol">)</a> <a id="18375" class="Symbol">(</a><a id="18376" href="Data.Fin.Base.html#1053" class="InductiveConstructor">suc</a> <a id="18380" href="VecMat.html#18346" class="Bound">i</a><a id="18381" class="Symbol">)</a> <a id="18383" href="VecMat.html#18349" class="Bound">k</a>                                           <a id="18427" href="Relation.Binary.Reasoning.Base.Single.html#1212" class="Function Operator">≡⟨⟩</a>
      <a id="18437" href="VecMat.html#16510" class="Function">1ₘ</a> <a id="18440" class="Symbol">(</a><a id="18441" href="Data.Fin.Base.html#1053" class="InductiveConstructor">suc</a> <a id="18445" href="VecMat.html#18346" class="Bound">i</a><a id="18446" class="Symbol">)</a> <a id="18448" href="Data.Fin.Base.html#1022" class="InductiveConstructor">zero</a> <a id="18453" href="Algebra.html#12243" class="Field Operator">*</a> <a id="18455" href="VecMat.html#18339" class="Bound">M</a> <a id="18457" href="Data.Fin.Base.html#1022" class="InductiveConstructor">zero</a> <a id="18462" href="VecMat.html#18349" class="Bound">k</a>
                    <a id="18484" href="Algebra.html#12214" class="Field Operator">+</a> <a id="18486" class="Symbol">(</a><a id="18487" href="VecMat.html#16575" class="Function">sum</a> <a id="18491" class="Symbol">\</a> <a id="18493" href="VecMat.html#18493" class="Bound">j</a> <a id="18495" class="Symbol">→</a> <a id="18497" href="VecMat.html#16510" class="Function">1ₘ</a> <a id="18500" class="Symbol">(</a><a id="18501" href="Data.Fin.Base.html#1053" class="InductiveConstructor">suc</a> <a id="18505" href="VecMat.html#18346" class="Bound">i</a><a id="18506" class="Symbol">)</a> <a id="18508" class="Symbol">(</a><a id="18509" href="Data.Fin.Base.html#1053" class="InductiveConstructor">suc</a> <a id="18513" href="VecMat.html#18493" class="Bound">j</a><a id="18514" class="Symbol">)</a> <a id="18516" href="Algebra.html#12243" class="Field Operator">*</a> <a id="18518" href="VecMat.html#18339" class="Bound">M</a> <a id="18520" class="Symbol">(</a><a id="18521" href="Data.Fin.Base.html#1053" class="InductiveConstructor">suc</a> <a id="18525" href="VecMat.html#18493" class="Bound">j</a><a id="18526" class="Symbol">)</a> <a id="18528" href="VecMat.html#18349" class="Bound">k</a><a id="18529" class="Symbol">)</a>  <a id="18532" href="Relation.Binary.Reasoning.Base.Single.html#1212" class="Function Operator">≡⟨⟩</a>
      <a id="18542" href="Algebra.html#12272" class="Field">0#</a> <a id="18545" href="Algebra.html#12243" class="Field Operator">*</a> <a id="18547" href="VecMat.html#18339" class="Bound">M</a> <a id="18549" href="Data.Fin.Base.html#1022" class="InductiveConstructor">zero</a> <a id="18554" href="VecMat.html#18349" class="Bound">k</a> <a id="18556" href="Algebra.html#12214" class="Field Operator">+</a> <a id="18558" class="Symbol">(</a><a id="18559" href="VecMat.html#16575" class="Function">sum</a> <a id="18563" class="Symbol">\</a> <a id="18565" href="VecMat.html#18565" class="Bound">j</a> <a id="18567" class="Symbol">→</a> <a id="18569" href="VecMat.html#16510" class="Function">1ₘ</a> <a id="18572" href="VecMat.html#18346" class="Bound">i</a> <a id="18574" href="VecMat.html#18565" class="Bound">j</a> <a id="18576" href="Algebra.html#12243" class="Field Operator">*</a> <a id="18578" href="VecMat.html#18339" class="Bound">M</a> <a id="18580" class="Symbol">(</a><a id="18581" href="Data.Fin.Base.html#1053" class="InductiveConstructor">suc</a> <a id="18585" href="VecMat.html#18565" class="Bound">j</a><a id="18586" class="Symbol">)</a> <a id="18588" href="VecMat.html#18349" class="Bound">k</a><a id="18589" class="Symbol">)</a>              <a id="18604" href="Relation.Binary.Reasoning.Base.Single.html#1212" class="Function Operator">≡⟨⟩</a>
      <a id="18614" href="Algebra.html#12272" class="Field">0#</a> <a id="18617" href="Algebra.html#12243" class="Field Operator">*</a> <a id="18619" href="VecMat.html#18339" class="Bound">M</a> <a id="18621" href="Data.Fin.Base.html#1022" class="InductiveConstructor">zero</a> <a id="18626" href="VecMat.html#18349" class="Bound">k</a> <a id="18628" href="Algebra.html#12214" class="Field Operator">+</a> <a id="18630" class="Symbol">(</a><a id="18631" href="VecMat.html#16510" class="Function">1ₘ</a> <a id="18634" href="VecMat.html#16679" class="Function Operator">*ₘ</a> <a id="18637" class="Symbol">(λ</a> <a id="18640" href="VecMat.html#18640" class="Bound">j</a> <a id="18642" href="VecMat.html#18642" class="Bound">k</a> <a id="18644" class="Symbol">→</a> <a id="18646" href="VecMat.html#18339" class="Bound">M</a> <a id="18648" class="Symbol">(</a><a id="18649" href="Data.Fin.Base.html#1053" class="InductiveConstructor">suc</a> <a id="18653" href="VecMat.html#18640" class="Bound">j</a><a id="18654" class="Symbol">)</a> <a id="18656" href="VecMat.html#18642" class="Bound">k</a><a id="18657" class="Symbol">))</a> <a id="18660" href="VecMat.html#18346" class="Bound">i</a> <a id="18662" href="VecMat.html#18349" class="Bound">k</a>
          <a id="18674" href="Relation.Binary.Reasoning.Base.Single.html#925" class="Function Operator">≈⟨</a> <a id="18677" href="Algebra.Structures.html#1078" class="Function">+-cong</a> <a id="18684" class="Symbol">(</a><a id="18685" href="Algebra.Structures.html#7988" class="Function">zeroˡ</a> <a id="18691" class="Symbol">_)</a> <a id="18694" class="Symbol">(</a><a id="18695" href="VecMat.html#17654" class="Function">*ₘ-identityˡ</a> <a id="18708" class="Symbol">{</a><a id="18709" href="VecMat.html#18332" class="Bound">m</a><a id="18710" class="Symbol">}</a> <a id="18712" class="Symbol">{</a><a id="18713" href="VecMat.html#18336" class="Bound">n</a><a id="18714" class="Symbol">}</a> <a id="18716" class="Symbol">(λ</a> <a id="18719" href="VecMat.html#18719" class="Bound">j</a> <a id="18721" href="VecMat.html#18721" class="Bound">k</a> <a id="18723" class="Symbol">→</a> <a id="18725" href="VecMat.html#18339" class="Bound">M</a> <a id="18727" class="Symbol">(</a><a id="18728" href="Data.Fin.Base.html#1053" class="InductiveConstructor">suc</a> <a id="18732" href="VecMat.html#18719" class="Bound">j</a><a id="18733" class="Symbol">)</a> <a id="18735" href="VecMat.html#18721" class="Bound">k</a><a id="18736" class="Symbol">)</a> <a id="18738" href="VecMat.html#18346" class="Bound">i</a> <a id="18740" href="VecMat.html#18349" class="Bound">k</a><a id="18741" class="Symbol">)</a> <a id="18743" href="Relation.Binary.Reasoning.Base.Single.html#925" class="Function Operator">⟩</a>
      <a id="18751" href="Algebra.html#12272" class="Field">0#</a>            <a id="18765" href="Algebra.html#12214" class="Field Operator">+</a> <a id="18767" href="VecMat.html#18339" class="Bound">M</a> <a id="18769" class="Symbol">(</a><a id="18770" href="Data.Fin.Base.html#1053" class="InductiveConstructor">suc</a> <a id="18774" href="VecMat.html#18346" class="Bound">i</a><a id="18775" class="Symbol">)</a> <a id="18777" href="VecMat.html#18349" class="Bound">k</a>                             <a id="18807" href="Relation.Binary.Reasoning.Base.Single.html#925" class="Function Operator">≈⟨</a> <a id="18810" href="Algebra.Structures.html#2610" class="Function">+-identityˡ</a> <a id="18822" class="Symbol">_</a> <a id="18824" href="Relation.Binary.Reasoning.Base.Single.html#925" class="Function Operator">⟩</a>
                      <a id="18848" href="VecMat.html#18339" class="Bound">M</a> <a id="18850" class="Symbol">(</a><a id="18851" href="Data.Fin.Base.html#1053" class="InductiveConstructor">suc</a> <a id="18855" href="VecMat.html#18346" class="Bound">i</a><a id="18856" class="Symbol">)</a> <a id="18858" href="VecMat.html#18349" class="Bound">k</a>                             <a id="18888" href="Relation.Binary.Reasoning.Base.Single.html#1295" class="Function Operator">∎</a>
      <a id="18896" class="Keyword">where</a> <a id="18902" class="Keyword">open</a> <a id="18907" href="Relation.Binary.Reasoning.Setoid.html" class="Module">SetoidReasoning</a> <a id="18923" href="Algebra.Structures.html#1153" class="Function">setoid</a>
</pre>
<p>The structure of this proof is very different from what it was last time, reflecting the differences in our definitions. In line with things being output-driven, the proof is by induction on the index <code>i</code> – a row number in the result. It can also be seen as being by induction on the dimension <code>m</code>, and then by cases on the index <code>i</code>. The steps of reasoning should look familiar to a mathematician. This is a proof by index notation where equations are all between coefficients rather than matrices, and we use both simple algebraic properties and properties of summation to simplify expressions. I invite the reader to actually read the reasoning steps, and to this end I have included some steps which are just computation and tried to move the proof terms (the ones inside <code>≈⟨ _ ⟩</code>) out of the way.</p>
<h2 id="behind-the-scenes">Behind the scenes</h2>
<p>There is still some sleight of hand at play in these proofs. The least sleight is the behaviour of <code>1ₘ</code>. For slick proofs, we require all four cases (<code>1ₘ zero zero</code>, <code>1ₘ zero (suc j)</code>, <code>1ₘ (suc i) zero</code>, and <code>1ₘ (suc i) (suc j)</code>) to compute in a convenient way. The first three should compute to their values, and the final one should compute to <code>1ₘ i j</code> so that we’re still in the realm of our inductive hypothesis. Without paying attention to this, it is quite easy to make an awkward definition of <code>1ₘ</code> that will make you miserable.</p>
<p>Perhaps the most obvious thing for an Agda programmer to do would be to think of what the identity matrix looks like, and implement it in such a way that this intuition is visible in the code. The thing we all remember about the identity matrix is that, for the position <code>(i, j)</code>, the coefficient is 1 when <code>i</code> = <code>j</code>, and 0 otherwise. So, let’s use the fact that equality is decidable on <code>Fin n</code>, and just write this down.</p>
<pre class="Agda">    <a id="Right.WithSemiring.1ₘd"></a><a id="20748" href="VecMat.html#20748" class="Function">1ₘd</a> <a id="20752" class="Symbol">:</a> <a id="20754" href="VecMat.html#14732" class="Function">Mat</a> <a id="20758" href="Algebra.html#12160" class="Field">Carrier</a> <a id="20766" href="VecMat.html#2729" class="Generalizable">m</a> <a id="20768" href="VecMat.html#2729" class="Generalizable">m</a>
    <a id="20774" href="VecMat.html#20748" class="Function">1ₘd</a> <a id="20778" href="VecMat.html#20778" class="Bound">i</a> <a id="20780" href="VecMat.html#20780" class="Bound">j</a> <a id="20782" class="Keyword">with</a> <a id="20787" href="VecMat.html#20778" class="Bound">i</a> <a id="20789" href="Data.Fin.Properties.html#1730" class="Function Operator">≟</a> <a id="20791" href="VecMat.html#20780" class="Bound">j</a>
    <a id="20797" class="Symbol">...</a> <a id="20801" class="Symbol">|</a> <a id="20803" href="Relation.Nullary.html#641" class="InductiveConstructor">yes</a> <a id="20807" class="Symbol">_</a> <a id="20809" class="Symbol">=</a> <a id="20811" href="Algebra.html#12297" class="Field">1#</a>
    <a id="20818" class="Symbol">...</a> <a id="20822" class="Symbol">|</a> <a id="20824" href="Relation.Nullary.html#668" class="InductiveConstructor">no</a> <a id="20827" class="Symbol">_</a> <a id="20829" class="Symbol">=</a> <a id="20831" href="Algebra.html#12272" class="Field">0#</a>
</pre>
<p>This satisfies three of the computation rules, but normalising <code>1ₘd (suc i) (suc j)</code> gives us <code>1ₘd (suc i) (suc j) | (suc i ≟ suc j | i ≟ j)</code>. In other words, computation depends on the result of <code>suc i ≟ suc j</code>, which is in turn not going to compute until we know more about <code>i ≟ j</code>. This is a real pain. When we used the boolean-valued equality test <code>_==_</code> earlier, we could say that <code>suc i == suc j</code> was <em>equal</em> to <code>i == j</code>. But with intrinsic decidable equality, <code>suc i ≟ suc j</code> and <code>i ≟ j</code> have different types, so we have to deconstruct and reconstruct our <code>Dec</code> values at the recursive call, fixing up the proofs depending on which side we’re on. One can go to the effort of proving that <code>1ₘd (suc i) (suc j) ≡ 1ₘd i j</code>, but I’m sure one would rather not. It would be an afterthought.</p>
<p>The sneakiest trick I pulled (though admittedly the one with least impact) is in the index <code>zero</code>. Notice that, in the case <code>*ₘ-identityˡ M zero k</code>, the right-hand side of our equation is <code>M zero k</code>. The <code>zero</code> here comes about because we’re in the case where <code>i = zero</code>. However, working from the left of the equation, we see that we get a new <code>zero</code> from <code>sum</code>. Specifically, <code>sum {suc n} v = v zero + sum {n} (v ∘ suc)</code>, and the <code>zero</code> in this expression is something we made up from nothing. Thus, we benefited from the fact that all <code>zero</code>es are judgementally equal.</p>
<p>It may seem obvious that there is only one <code>zero</code>, but when reïmplementing <code>Fin</code> as thinnings from 1, this is no longer easy. To recap, here is a definition of thinnings.</p>
<pre class="Agda">    <a id="22389" class="Keyword">data</a> <a id="Right.WithSemiring.Th"></a><a id="22394" href="VecMat.html#22394" class="Datatype">Th</a> <a id="22397" class="Symbol">:</a> <a id="22399" class="Symbol">(</a><a id="22400" href="VecMat.html#22400" class="Bound">m</a> <a id="22402" href="VecMat.html#22402" class="Bound">n</a> <a id="22404" class="Symbol">:</a> <a id="22406" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a><a id="22407" class="Symbol">)</a> <a id="22409" class="Symbol">→</a> <a id="22411" class="PrimitiveType">Set</a> <a id="22415" class="Keyword">where</a>
      <a id="Right.WithSemiring.Th.stop"></a><a id="22427" href="VecMat.html#22427" class="InductiveConstructor">stop</a> <a id="22432" class="Symbol">:</a> <a id="22434" href="VecMat.html#22394" class="Datatype">Th</a> <a id="22437" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a> <a id="22442" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a>
      <a id="Right.WithSemiring.Th.keep"></a><a id="22453" href="VecMat.html#22453" class="InductiveConstructor">keep</a> <a id="22458" class="Symbol">:</a> <a id="22460" href="VecMat.html#22394" class="Datatype">Th</a> <a id="22463" href="VecMat.html#2729" class="Generalizable">m</a> <a id="22465" href="VecMat.html#2731" class="Generalizable">n</a> <a id="22467" class="Symbol">→</a> <a id="22469" href="VecMat.html#22394" class="Datatype">Th</a> <a id="22472" class="Symbol">(</a><a id="22473" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="22477" href="VecMat.html#2729" class="Generalizable">m</a><a id="22478" class="Symbol">)</a> <a id="22480" class="Symbol">(</a><a id="22481" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="22485" href="VecMat.html#2731" class="Generalizable">n</a><a id="22486" class="Symbol">)</a>
      <a id="Right.WithSemiring.Th.drop"></a><a id="22494" href="VecMat.html#22494" class="InductiveConstructor">drop</a> <a id="22499" class="Symbol">:</a> <a id="22501" href="VecMat.html#22394" class="Datatype">Th</a> <a id="22504" href="VecMat.html#2729" class="Generalizable">m</a> <a id="22506" href="VecMat.html#2731" class="Generalizable">n</a> <a id="22508" class="Symbol">→</a> <a id="22510" href="VecMat.html#22394" class="Datatype">Th</a> <a id="22513" href="VecMat.html#2729" class="Generalizable">m</a> <a id="22515" class="Symbol">(</a><a id="22516" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="22520" href="VecMat.html#2731" class="Generalizable">n</a><a id="22521" class="Symbol">)</a>
</pre>
<p>The intended semantics is that a value of type <code>Th m n</code> is the instructions for how to take a vector of length <code>n</code> and produce a vector of smaller length <code>m</code> by only keeping some of the original elements. Thus, a value of <code>Th 1 n</code> describes how to pick 1 element out of a vector of length <code>n</code>.</p>
<p><code>Th 1 n</code> is equivalent to <code>Fin n</code>. Moreover, the induction on them is very similar, as shown by this conversion function.</p>
<pre class="Agda">    <a id="Right.WithSemiring.Th-to-Fin"></a><a id="22958" href="VecMat.html#22958" class="Function">Th-to-Fin</a> <a id="22968" class="Symbol">:</a> <a id="22970" href="VecMat.html#22394" class="Datatype">Th</a> <a id="22973" class="Number">1</a> <a id="22975" href="VecMat.html#2731" class="Generalizable">n</a> <a id="22977" class="Symbol">→</a> <a id="22979" href="Data.Fin.Base.html#1000" class="Datatype">Fin</a> <a id="22983" href="VecMat.html#2731" class="Generalizable">n</a>
    <a id="22989" href="VecMat.html#22958" class="Function">Th-to-Fin</a> <a id="22999" class="Symbol">(</a><a id="23000" href="VecMat.html#22453" class="InductiveConstructor">keep</a> <a id="23005" href="VecMat.html#23005" class="Bound">θ</a><a id="23006" class="Symbol">)</a> <a id="23008" class="Symbol">=</a> <a id="23010" href="Data.Fin.Base.html#1022" class="InductiveConstructor">zero</a>
    <a id="23019" href="VecMat.html#22958" class="Function">Th-to-Fin</a> <a id="23029" class="Symbol">(</a><a id="23030" href="VecMat.html#22494" class="InductiveConstructor">drop</a> <a id="23035" href="VecMat.html#23035" class="Bound">θ</a><a id="23036" class="Symbol">)</a> <a id="23038" class="Symbol">=</a> <a id="23040" href="Data.Fin.Base.html#1053" class="InductiveConstructor">suc</a> <a id="23044" class="Symbol">(</a><a id="23045" href="VecMat.html#22958" class="Function">Th-to-Fin</a> <a id="23055" href="VecMat.html#23035" class="Bound">θ</a><a id="23056" class="Symbol">)</a>
</pre>
<p>There is no case for <code>stop</code>, as <code>1 ≠ 0</code>. <code>keep</code> means that we’re keeping the first element, or in other words choosing the first element, so this corresponds to the index <code>zero</code>. <code>drop</code> means that we’re not keeping the first element, so the index must be somewhere later.</p>
<p>In the <code>keep</code> case, <code>θ</code> has type <code>Th 0 n</code>. Referring back to the semantics, this means that we’re not going to pick any more elements, so it must be that <code>θ</code> is <code>n</code>-many <code>drop</code>s followed by a <code>stop</code>. However, we cannot see this judgementally, so whenever we come across a case <code>keep θ</code>, we must reason it equal to any other representation of <code>zero</code>. In our proof <code>*ₘ-identityˡ</code>, this means adding a fixup line at the end of the <code>i = zero</code> case that rewrites by a propositional equality proof.</p>
<h2 id="conclusions">Conclusions</h2>
<p>I like this case study because several of the recommendations I make go against one piece of common wisdom or another. One really has to think critically about requirements rather than just doing what has worked before (or, in my case, try out every possible approach and see which one works best).</p>
<p>It tells us something about the Standard Library, or more generally about the requirements of any standard library for Agda. In particular, we can’t replace <code>Fin</code> by <code>Th 1</code> and expect everything to keep working, and even when we have <code>Dec</code> proofs, sometimes a <code>Bool</code> version of the same thing is necessary. Perhaps we should have a type <code>EDec</code> for extrinsic decidability, complementing intrinsic decidability from <code>Dec</code>.</p>
<pre class="Agda">    <a id="Right.WithSemiring.EDec"></a><a id="24589" href="VecMat.html#24589" class="Function">EDec</a> <a id="24594" class="Symbol">:</a> <a id="24596" class="PrimitiveType">Set</a> <a id="24600" href="VecMat.html#2624" class="Generalizable">a</a> <a id="24602" class="Symbol">→</a> <a id="24604" class="PrimitiveType">Set</a> <a id="24608" href="VecMat.html#2624" class="Generalizable">a</a>
    <a id="24614" href="VecMat.html#24589" class="Function">EDec</a> <a id="24619" href="VecMat.html#24619" class="Bound">A</a> <a id="24621" class="Symbol">=</a> <a id="24623" href="Data.Product.html#1364" class="Function">∃</a> <a id="24625" class="Symbol">\</a> <a id="24627" class="Symbol">(</a><a id="24628" href="VecMat.html#24628" class="Bound">b</a> <a id="24630" class="Symbol">:</a> <a id="24632" href="Agda.Builtin.Bool.html#135" class="Datatype">Bool</a><a id="24636" class="Symbol">)</a> <a id="24638" class="Symbol">→</a> <a id="24640" href="Data.Bool.Base.html#1312" class="Function Operator">if</a> <a id="24643" href="VecMat.html#24628" class="Bound">b</a> <a id="24645" href="Data.Bool.Base.html#1312" class="Function Operator">then</a> <a id="24650" href="VecMat.html#24619" class="Bound">A</a> <a id="24652" href="Data.Bool.Base.html#1312" class="Function Operator">else</a> <a id="24657" href="Relation.Nullary.html#535" class="Function Operator">¬</a> <a id="24659" href="VecMat.html#24619" class="Bound">A</a>

    <a id="Right.WithSemiring._≟ᴱ_"></a><a id="24666" href="VecMat.html#24666" class="Function Operator">_≟ᴱ_</a> <a id="24671" class="Symbol">:</a> <a id="24673" class="Symbol">(</a><a id="24674" href="VecMat.html#24674" class="Bound">i</a> <a id="24676" href="VecMat.html#24676" class="Bound">j</a> <a id="24678" class="Symbol">:</a> <a id="24680" href="Data.Fin.Base.html#1000" class="Datatype">Fin</a> <a id="24684" href="VecMat.html#2731" class="Generalizable">n</a><a id="24685" class="Symbol">)</a> <a id="24687" class="Symbol">→</a> <a id="24689" href="VecMat.html#24589" class="Function">EDec</a> <a id="24694" class="Symbol">(</a><a id="24695" href="VecMat.html#24674" class="Bound">i</a> <a id="24697" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="24699" href="VecMat.html#24676" class="Bound">j</a><a id="24700" class="Symbol">)</a>
    <a id="24706" href="Data.Fin.Base.html#1022" class="InductiveConstructor">zero</a> <a id="24711" href="VecMat.html#24666" class="Function Operator">≟ᴱ</a> <a id="24714" href="Data.Fin.Base.html#1022" class="InductiveConstructor">zero</a> <a id="24719" class="Symbol">=</a> <a id="24721" href="Agda.Builtin.Bool.html#160" class="InductiveConstructor">true</a> <a id="24726" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="24728" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">≡.refl</a>
    <a id="24739" href="Data.Fin.Base.html#1022" class="InductiveConstructor">zero</a> <a id="24744" href="VecMat.html#24666" class="Function Operator">≟ᴱ</a> <a id="24747" href="Data.Fin.Base.html#1053" class="InductiveConstructor">suc</a> <a id="24751" href="VecMat.html#24751" class="Bound">j</a> <a id="24753" class="Symbol">=</a> <a id="24755" href="Agda.Builtin.Bool.html#154" class="InductiveConstructor">false</a> <a id="24761" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="24763" class="Symbol">λ</a> <a id="24765" class="Symbol">()</a>
    <a id="24772" href="Data.Fin.Base.html#1053" class="InductiveConstructor">suc</a> <a id="24776" href="VecMat.html#24776" class="Bound">i</a> <a id="24778" href="VecMat.html#24666" class="Function Operator">≟ᴱ</a> <a id="24781" href="Data.Fin.Base.html#1022" class="InductiveConstructor">zero</a> <a id="24786" class="Symbol">=</a> <a id="24788" href="Agda.Builtin.Bool.html#154" class="InductiveConstructor">false</a> <a id="24794" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="24796" class="Symbol">λ</a> <a id="24798" class="Symbol">()</a>
    <a id="24805" href="Data.Fin.Base.html#1053" class="InductiveConstructor">suc</a> <a id="24809" href="VecMat.html#24809" class="Bound">i</a> <a id="24811" href="VecMat.html#24666" class="Function Operator">≟ᴱ</a> <a id="24814" href="Data.Fin.Base.html#1053" class="InductiveConstructor">suc</a> <a id="24818" href="VecMat.html#24818" class="Bound">j</a> <a id="24820" class="Symbol">=</a> <a id="24822" href="Data.Product.html#2430" class="Function">Σ.map</a> <a id="24828" href="Function.html#708" class="Function">id</a> <a id="24831" href="VecMat.html#24861" class="Function">go</a> <a id="24834" class="Symbol">(</a><a id="24835" href="VecMat.html#24809" class="Bound">i</a> <a id="24837" href="VecMat.html#24666" class="Function Operator">≟ᴱ</a> <a id="24840" href="VecMat.html#24818" class="Bound">j</a><a id="24841" class="Symbol">)</a>
      <a id="24849" class="Keyword">where</a>
      <a id="24861" href="VecMat.html#24861" class="Function">go</a> <a id="24864" class="Symbol">:</a> <a id="24866" class="Symbol">∀</a> <a id="24868" class="Symbol">{</a><a id="24869" href="VecMat.html#24869" class="Bound">b</a><a id="24870" class="Symbol">}</a> <a id="24872" class="Symbol">→</a> <a id="24874" href="Data.Bool.Base.html#1312" class="Function Operator">if</a> <a id="24877" href="VecMat.html#24869" class="Bound">b</a> <a id="24879" href="Data.Bool.Base.html#1312" class="Function Operator">then</a> <a id="24884" href="VecMat.html#24809" class="Bound">i</a> <a id="24886" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="24888" href="VecMat.html#24818" class="Bound">j</a> <a id="24890" href="Data.Bool.Base.html#1312" class="Function Operator">else</a> <a id="24895" href="VecMat.html#24809" class="Bound">i</a> <a id="24897" href="Relation.Binary.PropositionalEquality.Core.html#799" class="Function Operator">≢</a> <a id="24899" href="VecMat.html#24818" class="Bound">j</a> <a id="24901" class="Symbol">→</a>
                   <a id="24922" href="Data.Bool.Base.html#1312" class="Function Operator">if</a> <a id="24925" href="VecMat.html#24869" class="Bound">b</a> <a id="24927" href="Data.Bool.Base.html#1312" class="Function Operator">then</a> <a id="24932" href="Data.Fin.Base.html#1053" class="InductiveConstructor">suc</a> <a id="24936" href="VecMat.html#24809" class="Bound">i</a> <a id="24938" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="24940" href="Data.Fin.Base.html#1053" class="InductiveConstructor">suc</a> <a id="24944" href="VecMat.html#24818" class="Bound">j</a> <a id="24946" href="Data.Bool.Base.html#1312" class="Function Operator">else</a> <a id="24951" href="Data.Fin.Base.html#1053" class="InductiveConstructor">suc</a> <a id="24955" href="VecMat.html#24809" class="Bound">i</a> <a id="24957" href="Relation.Binary.PropositionalEquality.Core.html#799" class="Function Operator">≢</a> <a id="24959" href="Data.Fin.Base.html#1053" class="InductiveConstructor">suc</a> <a id="24963" href="VecMat.html#24818" class="Bound">j</a>
      <a id="24971" href="VecMat.html#24861" class="Function">go</a> <a id="24974" class="Symbol">{</a><a id="24975" href="Agda.Builtin.Bool.html#154" class="InductiveConstructor">false</a><a id="24980" class="Symbol">}</a> <a id="24982" href="VecMat.html#24982" class="Bound">i≢j</a> <a id="24986" href="VecMat.html#24986" class="Bound">si≡sj</a> <a id="24992" class="Symbol">=</a> <a id="24994" href="VecMat.html#24982" class="Bound">i≢j</a> <a id="24998" class="Symbol">(</a><a id="24999" href="Data.Fin.Properties.html#1626" class="Function">suc-injective</a> <a id="25013" href="VecMat.html#24986" class="Bound">si≡sj</a><a id="25018" class="Symbol">)</a>
      <a id="25026" href="VecMat.html#24861" class="Function">go</a> <a id="25029" class="Symbol">{</a><a id="25030" href="Agda.Builtin.Bool.html#160" class="InductiveConstructor">true</a><a id="25034" class="Symbol">}</a> <a id="25036" href="VecMat.html#25036" class="Bound">i≡j</a> <a id="25040" class="Symbol">=</a> <a id="25042" href="Relation.Binary.PropositionalEquality.Core.html#1090" class="Function">≡.cong</a> <a id="25049" href="Data.Fin.Base.html#1053" class="InductiveConstructor">suc</a> <a id="25053" href="VecMat.html#25036" class="Bound">i≡j</a>

    <a id="Right.WithSemiring.1ₘe"></a><a id="25062" href="VecMat.html#25062" class="Function">1ₘe</a> <a id="25066" class="Symbol">:</a> <a id="25068" href="VecMat.html#14732" class="Function">Mat</a> <a id="25072" href="Algebra.html#12160" class="Field">Carrier</a> <a id="25080" href="VecMat.html#2729" class="Generalizable">m</a> <a id="25082" href="VecMat.html#2729" class="Generalizable">m</a>
    <a id="25088" href="VecMat.html#25062" class="Function">1ₘe</a> <a id="25092" href="VecMat.html#25092" class="Bound">i</a> <a id="25094" href="VecMat.html#25094" class="Bound">j</a> <a id="25096" class="Symbol">=</a> <a id="25098" href="Data.Bool.Base.html#1312" class="Function Operator">if</a> <a id="25101" href="Agda.Builtin.Sigma.html#225" class="Field">proj₁</a> <a id="25107" class="Symbol">(</a><a id="25108" href="VecMat.html#25092" class="Bound">i</a> <a id="25110" href="VecMat.html#24666" class="Function Operator">≟ᴱ</a> <a id="25113" href="VecMat.html#25094" class="Bound">j</a><a id="25114" class="Symbol">)</a> <a id="25116" href="Data.Bool.Base.html#1312" class="Function Operator">then</a> <a id="25121" href="Algebra.html#12297" class="Field">1#</a> <a id="25124" href="Data.Bool.Base.html#1312" class="Function Operator">else</a> <a id="25129" href="Algebra.html#12272" class="Field">0#</a>
</pre>
<p>We can take this all the way back to the fact that Σ, 2, and large eliminations are enough to implement binary sums. It’s interesting to note, though, the differences at the level of judgemental equality. Indeed, <code>proj₁ (suc i ≟ᴱ suc j)</code> computes to <code>proj₁ (i ≟ᴱ j)</code>, as we wanted.</p>
<p>The second definition of <code>Vec</code> is similar to stdlib’s <code>Data.Table</code>. I import it here just so you can click and find the definition.</p>
<pre class="Agda">    <a id="25565" class="Keyword">open</a> <a id="25570" class="Keyword">import</a> <a id="25577" href="Data.Table.html" class="Module">Data.Table</a> <a id="25588" class="Keyword">using</a> <a id="25594" class="Symbol">(</a><a id="25595" href="Data.Table.Base.html#683" class="Record">Table</a><a id="25600" class="Symbol">)</a>
</pre>
<p>The only difference between my <code>Vec</code> and <code>Table</code> is that <code>Table</code> is a single-field record rather than just a definition. The technique of creating a single-field record is often a useful one. For example, if we had dependent tables, where elements at different indices could have different types, the following definition would be best.</p>
<pre class="Agda">    <a id="25957" class="Keyword">record</a> <a id="Right.WithSemiring.DTable"></a><a id="25964" href="VecMat.html#25964" class="Record">DTable</a> <a id="25971" href="VecMat.html#25971" class="Bound">n</a> <a id="25973" class="Symbol">(</a><a id="25974" href="VecMat.html#25974" class="Bound">A</a> <a id="25976" class="Symbol">:</a> <a id="25978" href="Data.Fin.Base.html#1000" class="Datatype">Fin</a> <a id="25982" href="VecMat.html#25971" class="Bound">n</a> <a id="25984" class="Symbol">→</a> <a id="25986" class="PrimitiveType">Set</a> <a id="25990" href="VecMat.html#2624" class="Generalizable">a</a><a id="25991" class="Symbol">)</a> <a id="25993" class="Symbol">:</a> <a id="25995" class="PrimitiveType">Set</a> <a id="25999" href="VecMat.html#25990" class="Bound">a</a> <a id="26001" class="Keyword">where</a>
      <a id="26013" class="Keyword">constructor</a> <a id="Right.WithSemiring.DTable.mk"></a><a id="26025" href="VecMat.html#26025" class="InductiveConstructor">mk</a>
      <a id="26034" class="Keyword">field</a> <a id="Right.WithSemiring.DTable.get"></a><a id="26040" href="VecMat.html#26040" class="Field">get</a> <a id="26044" class="Symbol">:</a> <a id="26046" class="Symbol">(</a><a id="26047" href="VecMat.html#26047" class="Bound">i</a> <a id="26049" class="Symbol">:</a> <a id="26051" href="Data.Fin.Base.html#1000" class="Datatype">Fin</a> <a id="26055" href="VecMat.html#25971" class="Bound">n</a><a id="26056" class="Symbol">)</a> <a id="26058" class="Symbol">→</a> <a id="26060" href="VecMat.html#25974" class="Bound">A</a> <a id="26062" href="VecMat.html#26047" class="Bound">i</a>
    <a id="26068" class="Keyword">open</a> <a id="26073" href="VecMat.html#25964" class="Module">DTable</a> <a id="26080" class="Keyword">public</a>
</pre>
<p>When we have a term <code>t : DTable n A</code>, unification can easily recover both <code>n</code> and <code>A</code> because they are there in the type. Instead of <code>DTable n A</code> computing to <code>(i : Fin n) → A i</code>, the record declaration intuitively blocks the computation until we explicitly use the <code>get</code> accessor. Unification has trouble with inferring <code>A</code> from <code>(i : Fin n) → A i</code> because it is a higher-order term. However, in our specific case for <code>Vec</code> (as in stdlib’s <code>Table</code>), <code>A</code> is not a higher-order term, and there are no problems extracting <code>n</code> and <code>A</code> from <code>Fin n → A</code>. Thus stdlib’s definition of <code>Table</code> is overkill.</p>
<p>Questions and comments about all of this post are welcome.</p>
</body>
</html>
